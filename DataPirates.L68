00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 12/8/2021 1:28:50 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : CSS422_DISASSEMBLER
00000000                             3  * Written by : Data Pirates
00000000                             4  * Date       : Autumn 2021
00000000                             5  * Description: Scans a section of memory and attempts to
00000000                             6  *              convert the memoryâ€™s contents to a listing 
00000000                             7  *              of valid assembly language instructions
00000000                             8  *-----------------------------------------------------------
00000000                             9  
00000000                            10  
00000000                            11  *-------------------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            12  *=================================================================I/O_ROUTINES======================================================================================
00000000                            13  *-------------------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            14  
00001000                            15  START       ORG         $1000               ; Start program at $1000
00001000                            16  
00001000                            17  *--------------------------------------------------------------------------------------------------------------
00001000                            18  *   START OF PROGRAM
00001000                            19  *--------------------------------------------------------------------------------------------------------------
00001000                            20              
00001000                            21  INTRODUCTION
00001000  103C 000E                 22              MOVE.B      #14,D0              ; Program starting message
00001004  43F9 0000224C             23              LEA         INTRO,A1
0000100A  4E4F                      24              TRAP        #15      
0000100C                            25              
0000100C                            26  MAIN_START  
0000100C  6100 101A                 27              BSR         CLEAR_REG1          ; Clear all data registers    
00001010  4FF9 0000A000             28              LEA         stack,SP            ; Load stack pointer  
00001016  45F9 000024C8             29              LEA         main_buff,A2        ; Load buffer in A2
0000101C  2C4A                      30              MOVEA.L     A2,A6               ; Reference start of main buffer
0000101E                            31              
0000101E                            32              
0000101E                            33  *--------------------------------------------------------------------------------------------------------------
0000101E                            34  *   USER INPUT: User inputs upper and lower bound for dissasembler, from
0000101E                            35  *               there it will be added to a stack and checked if address 
0000101E                            36  *               is valid and will execute               
0000101E                            37  *
0000101E                            38  *   Registers used:
0000101E                            39  *       - A0: starting address (INPUT1)
0000101E                            40  *       - A4: ending address (INPUT2)
0000101E                            41  *       - D2: copy of address
0000101E                            42  *       - D3: helper register
0000101E                            43  *       - D5: boolean
0000101E                            44  *--------------------------------------------------------------------------------------------------------------
0000101E                            45      
0000101E                            46  GET_INPUT    
0000101E  303C 0001                 47              MOVE        #01,D0              ; Display string at A1
00001022  43F9 000023A0             48              LEA         INPUT1,A1           ; Prompt user to enter start boundary
00001028  3239 000023BA             49              MOVE.W      INPUT1_len,D1         
0000102E  4E4F                      50              TRAP        #15
00001030  D2FC 23BA                 51              ADDA        #INPUT1_len,A1      ; Adds user input after prompt
00001034  303C 0002                 52              MOVE        #02,D0              ; Read string from keyboard and store at A1      
00001038  4E4F                      53              TRAP        #15
0000103A  4EB9 0000112C             54              JSR         ASCII_TO_HEX        ; Save info to stack, checks if valid
00001040  BA3C 0000                 55              CMP.B       #$00,D5             ; Check if boolean is false
00001044                            56              
00001044  2848                      57              MOVEA.L     A0,A4         
00001046  103C 0001                 58              MOVE.B      #01,D0              ; Display string at A1
0000104A  43F9 000023BC             59              LEA         INPUT2,A1           ; Prompt user to enter end boundary
00001050  3239 000023D4             60              MOVE.W      INPUT2_len,D1         
00001056  4E4F                      61              TRAP        #15         
00001058  D3FC 000023D4             62              ADDA.L      #INPUT2_len,A1      ; Add user input after prompt
0000105E  103C 0002                 63              MOVE.B      #02,D0              ; Read string from keyboard and store at A1
00001062  4E4F                      64              TRAP        #15
00001064  4EB9 0000112C             65              JSR         ASCII_TO_HEX        ; Save info to stack, checks if valid
0000106A  BA3C 0000                 66              CMP.B       #$00,D5             ; Check if boolean is false
0000106E                            67              
0000106E  264C                      68              MOVEA.L     A4,A3               ; Stores starting address into A3
00001070  2848                      69              MOVEA.L     A0,A4               ; Stores endinging address into A4
00001072  204B                      70              MOVEA.L     A3,A0               ; Stores starting address into A0 to be swapped                   
00001074                            71              
00001074  6100 0044                 72              BSR         CHECK_ADDRESS       ; Check if address is valid           
00001078  BA7C 0000                 73              CMP         #FALSE,D5           ; If not valid, Bool = False
0000107C  67A0                      74              BEQ         GET_INPUT           ; Return to input prompts
0000107E                            75              
0000107E  6100 0142                 76              BSR         BUFFER              ; To fill buffer with current address
00001082                            77              
00001082  103C 0001                 78              MOVE.B      #01,D0
00001086  43F9 00002478             79              LEA         REPEAT,A1           ; Asks if user wants to enter new boundaries
0000108C  3239 000024B4             80              MOVE.W      REPEAT_len,D1
00001092  4E4F                      81              TRAP        #15
00001094                            82              
00001094  103C 0002                 83              MOVE.B      #02,D0              ; Read string from keyboard and store at A1
00001098  4E4F                      84              TRAP        #15
0000109A                            85              
0000109A  1611                      86              MOVE.B      (A1),D3             ; Copies user input to D3
0000109C                            87              
0000109C  12FC 0057                 88              MOVE.B      #$57,(A1)+          ; Write in 'W'
000010A0  12BC 006F                 89              MOVE.B      #$6F,(A1)           ; Write in 'u'
000010A4                            90              
000010A4  B63C 0031                 91              CMP.B       #$31,D3             ; Compares ASCII values to D3
000010A8  6700 FF62                 92              BEQ         MAIN_START
000010AC                            93               
000010AC  6700 FF5E                 94              BEQ         MAIN_START          ; Restart input prompts
000010B0                            95              
000010B0  6100 0160                 96              BSR         EXIT_PROGRAM        ; Exit program                  
000010B4  4EF9 000024CA             97              JMP         END        
000010BA                            98          
000010BA                            99          
000010BA                           100  *--------------------------------------------------------------------------------------------------------------
000010BA                           101  *   CHECK ADDRESS VALIDITY: Checks if address is even, is within boundaries, and if
000010BA                           102  *                           the starting address isn't greater than the ending
000010BA                           103  *   
000010BA                           104  *   Registers used:
000010BA                           105  *       - A0: starting address (INPUT1)
000010BA                           106  *       - A4: ending address (INPUT2)
000010BA                           107  *       - D2: copy of address
000010BA                           108  *       - D3: helper register
000010BA                           109  *       - D5: boolean
000010BA                           110  *--------------------------------------------------------------------------------------------------------------
000010BA                           111                 
000010BA                           112  CHECK_ADDRESS:
000010BA                           113  
000010BA                           114  CHECK_START
000010BA  BA3C 0000                115              CMP.B       #$00,D5             ; Check if boolean is false
000010BE  6700 0054                116              BEQ         CHECK_ERROR         ; Address error
000010C2  1A3C 0001                117              MOVE.B      #TRUE,D5            ; Set boolean to true
000010C6                           118  
000010C6  2408                     119  ADD1        MOVE.L      A0,D2               ; Loads start boundary to D regs
000010C8  2602                     120              MOVE.L      D2,D3
000010CA  0203 0001                121              ANDI.B      #1,D3               ; Checks last bit in D2
000010CE  B63C 0001                122              CMP.B       #1,D3
000010D2  6600 0006                123              BNE         ADD2                ; Last bit = 0; go to even branch
000010D6                           124              
000010D6  5302                     125  SUB1        SUBI.B      #$1,D2              ; Allows odd address to be even
000010D8  2042                     126              MOVE.L      D2,A0    
000010DA                           127              
000010DA  240C                     128  ADD2        MOVE.L      A4,D2               ; Loads ending boundary to D regs
000010DC  2602                     129              MOVE.L      D2,D3
000010DE  0203 0001                130              ANDI.B      #1,D3               ; Checks last bit in D2
000010E2  B63C 0001                131              CMP.B       #1,D3
000010E6  6600 0006                132              BNE         EQU1 
000010EA                           133              
000010EA  5302                     134  SUB2        SUBI.B      #$1,D2              ; Allows odd address to be even
000010EC  2842                     135              MOVE.L      D2,A4
000010EE                           136                
000010EE  B1FC 00FFFFFF            137  EQU1        CMP.L       #maxBOUND,A0        ; Checks if starting address < $00FFFFFF
000010F4  6D00 0008                138              BLT         EQU2                ; If so, branch to EQU2        
000010F8  4EF9 00001114            139              JMP         CHECK_ERROR         ; If not, address error
000010FE                           140                  
000010FE  B9FC 00FFFFFF            141  EQU2        CMP.L       #maxBOUND,A4        ; checks if ending address <= $00FFFFFF
00001104  6F00 0008                142              BLE         EQU3                ; If so, branch to EQU3
00001108  4EF9 00001114            143              JMP         CHECK_ERROR         ; If not, address error               
0000110E                           144              
0000110E  B9C8                     145  EQU3        CMPA.L      A0,A4               ; Checks if ending address > starting address
00001110  6E00 0018                146              BGT         CHECK_END
00001114                           147                 
00001114                           148  CHECK_ERROR
00001114  103C 0000                149              MOVE.B      #00,D0
00001118  43F9 000023D6            150              LEA         ERRPARAM,A1         ; Display invalid parameter msg
0000111E  3239 000023FC            151              MOVE.W      PARAM_len,D1
00001124  4E4F                     152              TRAP        #15        
00001126  1A3C 0000                153              MOVE.B      #FALSE,D5           ; Bool = False
0000112A                           154                          
0000112A  4E75                     155  CHECK_END   RTS
0000112C                           156  
0000112C                           157  
0000112C                           158  *--------------------------------------------------------------------------------------------------------------
0000112C                           159  *   Ascii To Hex: Add data to stack, converts to hex, and checks length of address
0000112C                           160  *   
0000112C                           161  *   Registers used:
0000112C                           162  *       - D3: placeholder for current ascii byte   
0000112C                           163  *       - D4: translated address
0000112C                           164  *       - D5: boolean
0000112C                           165  *       - A0: stores the converted address
0000112C                           166  *--------------------------------------------------------------------------------------------------------------
0000112C                           167  
0000112C                           168  ASCII_TO_HEX
0000112C  48E7 F800                169              MOVEM.L     D0-D4,-(SP)         ; Saves data registers to stack
00001130  1A3C 0001                170              MOVE.B      #TRUE,D5            ; Bool = true
00001134  4EB9 00002064            171              JSR         CLEAR_REG2
0000113A  3C3C 0000                172              MOVE        #length,D6      
0000113E                           173        
0000113E                           174  CONVERT_TO_HEX
0000113E  1619                     175              MOVE.B      (A1)+,D3            ; Post increment address reg and move each byte to D3 (user's input)
00001140  B63C 0030                176              CMP.B       #$30,D3             ; If ascii byte < 30 and greater, its valid
00001144  6D00 0068                177              BLT         INVALID_HEX
00001148  B63C 003A                178              CMP.B       #$3A,D3             ; If ascii byte < 3A, convert to num
0000114C  6D00 0042                179              BLT         GET_NUMBER      
00001150  B63C 0041                180              CMP.B       #$41,D3             ; If ascii byte < 41, error
00001154  6D00 0058                181              BLT         INVALID_HEX
00001158  B63C 0047                182              CMP.B       #$47,D3             ; If ascii byte < 47, convert to cap
0000115C  6D00 003C                183              BLT         GET_CAPITAL
00001160  B63C 0061                184              CMP.B       #$61,D3             ; If ascii byte < 61, error
00001164  6D00 0048                185              BLT         INVALID_HEX
00001168  B63C 0067                186              CMP.B       #$67,D3             ; If ascii byte < 67, convert to lowercase
0000116C  6D00 0036                187              BLT         GET_LOWERCASE
00001170  B63C 0066                188              CMP.B       #$66,D3             ; If ascii byte > 66, error
00001174  6E00 0038                189              BGT         INVALID_HEX 
00001178                           190        
00001178                           191  NEXT_STEP    
00001178  5246                     192              ADD         #1,D6               ; if  the length of input in d1 is 0, then done
0000117A  BC7C 0006                193              CMP         #6,D6               ; compare to 6
0000117E  6700 0038                194              BEQ         RETURN              ; if length is 6 digits long, jump to return              
00001182  0C11 0000                195              CMP.B       #$00,(A1)           ; in case its null, done
00001186  6700 0030                196              BEQ         RETURN              ; move to exit subroutine
0000118A  E984                     197              ASL.L       #4,D4               ; shift D4 left by 4 bits for next value            
0000118C  4EF8 113E                198              JMP         CONVERT_TO_HEX      ; goes back to converting to hex for new val
00001190                           199  
00001190                           200  GET_NUMBER
00001190  0403 0030                201              SUBI.B      #$30,D3             ; converts val of d2 to hex number val
00001194  D803                     202              ADD.B       D3,D4               ; updates d4 with the latest hex
00001196  4EF8 1178                203              JMP         NEXT_STEP           ; goes to loop
0000119A                           204  
0000119A                           205  GET_CAPITAL
0000119A  0403 0037                206              SUBI.B      #$37,D3             ; converts to capital hex letter
0000119E  D803                     207              ADD.B       D3,D4               ; updates the D4 with latest hex
000011A0  4EF8 1178                208              JMP         NEXT_STEP           ; goes to loop
000011A4                           209  
000011A4                           210  GET_LOWERCASE
000011A4  0403 0057                211              SUBI.B      #$57,D3             ; converts lowercase hex value
000011A8  D803                     212              ADD.B       D3,D4               ; updates D4
000011AA  4EF8 1178                213              JMP         NEXT_STEP           ; goes to loop
000011AE                           214  
000011AE                           215  INVALID_HEX 
000011AE  1A3C 0000                216              MOVE.B      #00,D5              ; Checks if bool is FALSE      
000011B2  4EF9 000011B8            217              JMP         return              ; Exits subroutine
000011B8                           218  
000011B8  2044                     219  RETURN      MOVE.L      D4,A0               ; Moves the final address to A0
000011BA  4246                     220              CLR         D6                  ; Clears counter
000011BC  4CDF 001F                221              MOVEM.L     (SP)+,D0-D4         ; Load D registers from stack      
000011C0  4E75                     222              RTS                             ; Return from subroutine
000011C2                           223                 
000011C2                           224                 
000011C2                           225  *--------------------------------------------------------------------------------------------------------------
000011C2                           226  *   BUFFER: gets buffer ready for current address, OpCode, and EA
000011C2                           227  *
000011C2                           228  *   Registers used:   
000011C2                           229  *       - A0: current address
000011C2                           230  *       - A1: trap address
000011C2                           231  *       - A2: buffer pointer
000011C2                           232  *       - A4: ending address
000011C2                           233  *       - D0: task number
000011C2                           234  *       - D1: length for MORE_DATA
000011C2                           235  *       - D7: counter for number of lines printed
000011C2                           236  *--------------------------------------------------------------------------------------------------------------
000011C2                           237  
000011C2  244E                     238  BUFFER      MOVEA.L     A6,A2         
000011C4  224A                     239              MOVEA.L     A2,A1               ; Loads trap address with A2            
000011C6  4EB9 00001F9A            240              JSR         FORMAT_ADD          ; Print out address lines
000011CC  14FC 0009                241              MOVE.B      #$09,(A2)+          ; Fills buffer with current address
000011D0  4EB9 00001226            242              JSR         DECODE_OP
000011D6  14BC 0000                243              MOVE.B      #00,(A2)            ; Null terminater
000011DA  103C 000D                244              MOVE.B      #13,D0
000011DE  4E4F                     245              TRAP        #15                 ; Print decoded op
000011E0                           246                                
000011E0  B9C8                     247              CMPA.L      A0,A4               ; Continues to end of address range
000011E2  6F00 002C                248              BLE         END_BUFFER
000011E6                           249              
000011E6  5247                     250              ADDI        #1,D7               ; Increments a counter
000011E8  BE7C 0019                251              CMP         #lineCount,D7       ; Checks how many lines to increment
000011EC  66D4                     252              BNE         BUFFER
000011EE                           253              
000011EE  103C 0001                254              MOVE.B      #01,D0              ; Display string at A1
000011F2  43F9 0000245C            255              LEA         MORE_DATA,A1        ; Asks user to press enter for more data
000011F8  3239 00002476            256              MOVE.W      MORE_len,D1
000011FE  4E4F                     257              TRAP        #15
00001200                           258              
00001200  103C 0002                259              MOVE.B      #02,D0              ; Read string from keyboard and store at A1
00001204  4E4F                     260              TRAP        #15
00001206                           261              
00001206  12BC 0050                262              MOVE.B      #$50,(A1)
0000120A                           263              
0000120A  4247                     264              CLR         D7                  ; Resets the counter
0000120C  4EF8 11C2                265              JMP         BUFFER
00001210                           266              
00001210  4E75                     267  END_BUFFER  RTS     
00001212                           268  
00001212                           269  
00001212                           270  *--------------------------------------------------------------------------------------------------------------
00001212                           271  *   Exit Method
00001212                           272  *--------------------------------------------------------------------------------------------------------------
00001212                           273  
00001212                           274  EXIT_PROGRAM            
00001212  103C 0001                275              MOVE.B      #01,D0              ; Display string at A1
00001216  43F9 000024B6            276              LEA         EXIT,A1
0000121C  3239 000024C6            277              MOVE.W      EXIT_len,D1
00001222  4E4F                     278              TRAP        #15
00001224  4E75                     279              RTS   
00001226                           280  
00001226                           281  
00001226                           282  *-------------------------------------------------------------------------------------------------------------------------------------------------------------------
00001226                           283  *==============================================================OPCODE_ROUTINES======================================================================================
00001226                           284  *-------------------------------------------------------------------------------------------------------------------------------------------------------------------
00001226                           285  
00001226                           286  *--------------------------------------------------------------------------------------------------------------
00001226                           287  *   START OF DECODE
00001226                           288  *
00001226                           289  *   Registers used:   
00001226                           290  *       - A0/A5: Memory pointer
00001226                           291  *       - A2: buffer pointer
00001226                           292  *       - A5: index for jump tables
00001226                           293  *       - A6: holds previous buffer spot
00001226                           294  *       - A7: SP
00001226                           295  *       - D2: size returned from GET_SIZE
00001226                           296  *       - D5: boolean
00001226                           297  *       - D6: copy of D7 to shift
00001226                           298  *       - D7: current word value
00001226                           299  *       - (A1, D0, D1: trap funtions)
00001226                           300  *--------------------------------------------------------------------------------------------------------------
00001226                           301            
00001226  48E7 FB0E                302  DECODE_OP   MOVEM.L     A4-A6/D0-D4/D6-D7,-(SP)      ; Registers to be saved using MOVEM
0000122A  4EB9 00002064            303              JSR         CLEAR_REG2                   ; Registers are cleared to be used
00001230  1A3C 0001                304              MOVE.B      #TRUE,D5                     ; Bool = TRUE
00001234  3E18                     305              MOVE.W      (A0)+,D7            ; Move instructions to D7 and increment pointer
00001236  264A                     306              MOVEA.L     A2,A3               ; Stores buffer location                 
00001238  4EB9 0000124E            307              JSR         GET_OP              ; Decode instruction to get opcode
0000123E                           308  
0000123E                           309  INVALID_OP 
0000123E  1A3C 0000                310              MOVE.B      #00,D5              ; Checks if bool is FALSE      
00001242  4EF9 00001248            311              JMP         RETURN_OP           ; Exits subroutine
00001248                           312  
00001248  4CDF 70DF                313  RETURN_OP   MOVEM.L     (SP)+,D6-D7/D0-D4/A4-A6      ; Clean and restore registers
0000124C  4E75                     314              RTS                    
0000124E                           315                   
0000124E  3C07                     316  GET_OP      MOVE.W      D7,D6               ; Move instruction to shift
00001250  183C 000C                317              MOVE.B      #12,D4              ; Load shift register for 12 bits
00001254  E86E                     318              LSR.W       D4,D6               ; Shift register 12 bits right
00001256  CCFC 0006                319              MULU        #6,D6               ; Forms offset           
0000125A  4BF9 00001266            320              LEA         OP_TABLE,A5         ; Access table                                                                                   
00001260  4EB5 6000                321              JSR         00(A5,D6)           ; Jump indirect with index (00 indicates word movement)
00001264  4E75                     322              RTS
00001266                           323  
00001266                           324  
00001266                           325  *--------------------------------------------------------------------------------------------------------------
00001266                           326  *   MAIN OPCODE TABLE (first 4 bits)
00001266                           327  *--------------------------------------------------------------------------------------------------------------
00001266                           328  
00001266                           329  OP_TABLE      
00001266  4EF9 000012C6            330              JMP         GROUP1_0000            
0000126C  4EF9 00001484            331              JMP         GROUP1_0001            
00001272  4EF9 000014C0            332              JMP         GROUP1_0010
00001278  4EF9 00001526            333              JMP         GROUP1_0011
0000127E  4EF9 0000158C            334              JMP         GROUP1_0100
00001284  4EF9 000015F0            335              JMP         GROUP1_0101
0000128A  4EF9 000015F8            336              JMP         GROUP1_0110
00001290  4EF9 00001602            337              JMP         GROUP1_0111
00001296  4EF9 0000160A            338              JMP         GROUP1_1000
0000129C  4EF9 00001684            339              JMP         GROUP1_1001
000012A2  4EF9 00001742            340              JMP         GROUP1_1010
000012A8  4EF9 0000174A            341              JMP         GROUP1_1011
000012AE  4EF9 0000183C            342              JMP         GROUP1_1100
000012B4  4EF9 000019B4            343              JMP         GROUP1_1101
000012BA  4EF9 00001A72            344              JMP         GROUP1_1110
000012C0  4EF9 00001BF0            345              JMP         GROUP1_1111
000012C6                           346              
000012C6                           347  
000012C6                           348  *--------------------------------------------------------------------------------------------------------------
000012C6                           349  *   OPCODE: 0000 (ORI, ANDI, SUBI, ADDI, EORI, CMP)
000012C6                           350  *--------------------------------------------------------------------------------------------------------------
000012C6                           351  
000012C6                           352  GROUP1_0000 
000012C6  3C07                     353              MOVE.W      D7,D6               ; Copy of instruction to shift
000012C8  0246 0F00                354              ANDI.W      #$0F00,D6           ; Gets second last bit of address
000012CC  183C 0008                355              MOVE.B      #08,D4              ; Assigns D4 with 8 bits to shift
000012D0  E8AE                     356              LSR.L       D4,D6               ; Shift D6 by 8 bits
000012D2  BC3C 0000                357              CMP.B       #$0,D6              ; Is instruction ORI?
000012D6  6700 006A                358              BEQ         OP_ORI              ; Puts ORI into buffer
000012DA  BC3C 0002                359              CMP.B       #$2,D6              ; Is instruction ANDI?
000012DE  6700 00A2                360              BEQ         OP_ANDI             ; Puts ANDI into buffer
000012E2  BC3C 0004                361              CMP.B       #$4,D6              ; Is instruction SUBI?
000012E6  6700 00DA                362              BEQ         OP_SUBI             ; Puts SUBI into buffer
000012EA  BC3C 0006                363              CMP.B       #$6,D6              ; Is instruction ADDI?
000012EE  6700 0112                364              BEQ         OP_ADDI             ; Puts ADDI into buffer
000012F2  BC3C 000A                365              CMP.B       #$A,D6              ; Is instruction EORI?
000012F6  6700 014A                366              BEQ         OP_EORI             ; Puts opEORI into buffer
000012FA  BC3C 000C                367              CMP.B       #$C,D6              ; Is instruction CMPI?
000012FE  6600 0C16                368              BNE         INVALID_INST        ; If not one of these instructions, return DATA                 
00001302                           369  
00001302  14FC 0043                370  OP_CMPI     MOVE.B      #'C',(A2)+          ; Put CMPI into buffer
00001306  14FC 004D                371              MOVE.B      #'M',(A2)+
0000130A  14FC 0050                372              MOVE.B      #'P',(A2)+
0000130E  14FC 0049                373              MOVE.B      #'I',(A2)+
00001312  14FC 002E                374              MOVE.B      #'.',(A2)+
00001316  4EB9 00001DFE            375              JSR         FIND_SIZE           ; Decides whether B,W,L
0000131C  14FC 0020                376              MOVE.B      #' ',(A2)+
00001320  14FC 0020                377              MOVE.B      #' ',(A2)+
00001324  14FC 0020                378              MOVE.B      #' ',(A2)+            
00001328  14FC 0023                379              MOVE.B      #'#',(A2)+
0000132C  4EB9 00001EFC            380              JSR         LOAD_SIZE           ; Load size amount into buffer
00001332  14FC 002C                381              MOVE.B      #',',(A2)+          ; Adds comma between data
00001336  4EB9 00002074            382              JSR         GET_EA              ; Prints desitination operand
0000133C  4EF9 00001482            383              JMP         END0000             ; Jumps to end of subroute GROUP1_0000
00001342                           384                          
00001342  14FC 004F                385  OP_ORI      MOVE.B      #'O',(A2)+          ; Put ORI into buffer
00001346  14FC 0052                386              MOVE.B      #'R',(A2)+
0000134A  14FC 0049                387              MOVE.B      #'I',(A2)+
0000134E  14FC 002E                388              MOVE.B      #'.',(A2)+
00001352  4EB9 00001DFE            389              JSR         FIND_SIZE           ; Decides whether B,W,L
00001358  14FC 0020                390              MOVE.B      #' ',(A2)+
0000135C  14FC 0020                391              MOVE.B      #' ',(A2)+
00001360  14FC 0020                392              MOVE.B      #' ',(A2)+
00001364  14FC 0020                393              MOVE.B      #' ',(A2)+            
00001368  14FC 0023                394              MOVE.B      #'#',(A2)+            
0000136C  4EB9 00001EFC            395              JSR         LOAD_SIZE           ; Load size amount into buffer
00001372  14FC 002C                396              MOVE.B      #',',(A2)+          ; Adds comma between data
00001376  4EB9 00002074            397              JSR         GET_EA              ; Prints desitination operand
0000137C  4EF9 00001482            398              JMP         END0000             ; Jumps to end of subroute GROUP1_0000
00001382                           399  
00001382  14FC 0041                400  OP_ANDI     MOVE.B      #'A',(A2)+          ; Put ANDI into buffer
00001386  14FC 004E                401              MOVE.B      #'N',(A2)+
0000138A  14FC 0044                402              MOVE.B      #'D',(A2)+
0000138E  14FC 0049                403              MOVE.B      #'I',(A2)+
00001392  14FC 002E                404              MOVE.B      #'.',(A2)+
00001396  4EB9 00001DFE            405              JSR         FIND_SIZE           ; Decides whether B,W,L
0000139C  14FC 0020                406              MOVE.B      #' ',(A2)+
000013A0  14FC 0020                407              MOVE.B      #' ',(A2)+
000013A4  14FC 0020                408              MOVE.B      #' ',(A2)+            
000013A8  14FC 0023                409              MOVE.B      #'#',(A2)+           
000013AC  4EB9 00001EFC            410              JSR         LOAD_SIZE           ; Load size amount into buffer            
000013B2  14FC 002C                411              MOVE.B      #',',(A2)+          ; Adds comma between data
000013B6  4EB9 00002074            412              JSR         GET_EA              ; Prints desitination operand
000013BC  4EF9 00001482            413              JMP         END0000             ; Jumps to end of subroute GROUP1_0000
000013C2                           414              
000013C2  14FC 0053                415  OP_SUBI     MOVE.B      #'S',(A2)+          ; Put SUBI into buffer
000013C6  14FC 0055                416              MOVE.B      #'U',(A2)+
000013CA  14FC 0042                417              MOVE.B      #'B',(A2)+
000013CE  14FC 0049                418              MOVE.B      #'I',(A2)+
000013D2  14FC 002E                419              MOVE.B      #'.',(A2)+
000013D6  4EB9 00001DFE            420              JSR         FIND_SIZE           ; Decides whether B,W,L
000013DC  14FC 0020                421              MOVE.B      #' ',(A2)+
000013E0  14FC 0020                422              MOVE.B      #' ',(A2)+
000013E4  14FC 0020                423              MOVE.B      #' ',(A2)+            
000013E8  14FC 0023                424              MOVE.B      #'#',(A2)+
000013EC                           425              
000013EC  4EB9 00001EFC            426              JSR         LOAD_SIZE           ; Load size amount into buffer
000013F2  14FC 002C                427              MOVE.B      #',',(A2)+          ; Adds comma between data
000013F6  4EB9 00002074            428              JSR         GET_EA              ; Prints desitination operand
000013FC  4EF9 00001482            429              JMP         END0000             ; Jumps to end of subroute GROUP1_0000
00001402                           430              
00001402  14FC 0041                431  OP_ADDI     MOVE.B      #'A',(A2)+          ; Put ADDI into buffer
00001406  14FC 0044                432              MOVE.B      #'D',(A2)+
0000140A  14FC 0044                433              MOVE.B      #'D',(A2)+
0000140E  14FC 0049                434              MOVE.B      #'I',(A2)+
00001412  14FC 002E                435              MOVE.B      #'.',(A2)+
00001416  4EB9 00001DFE            436              JSR         FIND_SIZE           ; Decides whether B,W,L
0000141C  14FC 0020                437              MOVE.B      #' ',(A2)+
00001420  14FC 0020                438              MOVE.B      #' ',(A2)+
00001424  14FC 0020                439              MOVE.B      #' ',(A2)+            
00001428  14FC 0023                440              MOVE.B      #'#',(A2)+
0000142C  4EB9 00001EFC            441              JSR         LOAD_SIZE           ; Load size amount into buffer
00001432  14FC 002C                442              MOVE.B      #',',(A2)+          ; Adds comma between data
00001436  4EB9 00002074            443              JSR         GET_EA              ; Prints desitination operand
0000143C  4EF9 00001482            444              JMP         END0000             ; Jumps to end of subroute GROUP1_0000
00001442                           445  
00001442  14FC 0045                446  OP_EORI     MOVE.B      #'E',(A2)+          ; Put EORI into buffer
00001446  14FC 004F                447              MOVE.B      #'O',(A2)+
0000144A  14FC 0052                448              MOVE.B      #'R',(A2)+
0000144E  14FC 0049                449              MOVE.B      #'I',(A2)+
00001452  14FC 002E                450              MOVE.B      #'.',(A2)+
00001456  4EB9 00001DFE            451              JSR         FIND_SIZE           ; Decides whether B,W,L
0000145C  14FC 0020                452              MOVE.B      #' ',(A2)+
00001460  14FC 0020                453              MOVE.B      #' ',(A2)+
00001464  14FC 0020                454              MOVE.B      #' ',(A2)+            
00001468  14FC 0023                455              MOVE.B      #'#',(A2)+
0000146C  4EB9 00001EFC            456              JSR         LOAD_SIZE           ; Load size amount into buffer
00001472  14FC 002C                457              MOVE.B      #',',(A2)+          ; Adds comma between data
00001476  4EB9 00002074            458              JSR         GET_EA              ; Prints desitination operand
0000147C  4EF9 00001482            459              JMP         END0000             ; Jumps to end of subroute GROUP1_0000
00001482                           460              
00001482  4E75                     461  END0000     RTS
00001484                           462  
00001484                           463  
00001484                           464  *--------------------------------------------------------------------------------------------------------------
00001484                           465  *   OPCODE: 0001 (MOVE.B)
00001484                           466  *--------------------------------------------------------------------------------------------------------------
00001484                           467  
00001484                           468  GROUP1_0001 
00001484  14FC 004D                469              MOVE.B      #'M',(A2)+          ; Puts MOVE.B into buffer
00001488  14FC 004F                470              MOVE.B      #'O',(A2)+
0000148C  14FC 0056                471              MOVE.B      #'V',(A2)+
00001490  14FC 0045                472              MOVE.B      #'E',(A2)+
00001494  14FC 002E                473              MOVE.B      #'.',(A2)+
00001498  14FC 0042                474              MOVE.B      #'B',(A2)+
0000149C  14FC 0020                475              MOVE.B      #' ',(A2)+
000014A0  14FC 0020                476              MOVE.B      #' ',(A2)+
000014A4  14FC 0020                477              MOVE.B      #' ',(A2)+  
000014A8  4EB9 00002074            478              JSR         GET_EA              ; Prints desitination operand
000014AE  14FC 002C                479              MOVE.B      #',',(A2)+          ; Adds comma between data
000014B2  4EB9 00001E34            480              JSR         MOVE_SWAP           ; Swap the destination and source regs for GET_EA
000014B8  4EB9 00002074            481              JSR         GET_EA
000014BE                           482              
000014BE  4E75                     483  END0001     RTS 
000014C0                           484              
000014C0                           485              
000014C0                           486  *--------------------------------------------------------------------------------------------------------------
000014C0                           487  *   OPCODE: 0010 (MOVE.L, MOVEA.L)
000014C0                           488  *--------------------------------------------------------------------------------------------------------------
000014C0                           489  
000014C0                           490  GROUP1_0010 
000014C0  14FC 004D                491              MOVE.B      #'M',(A2)+          ; Puts MOVE/A sized L into buffer
000014C4  14FC 004F                492              MOVE.B      #'O',(A2)+
000014C8  14FC 0056                493              MOVE.B      #'V',(A2)+
000014CC  14FC 0045                494              MOVE.B      #'E',(A2)+
000014D0  1C07                     495              MOVE.B      D7,D6               ; Copies instruction to shift
000014D2  EC8E                     496              LSR.L       #6,D6               ; Shift by 6 bits
000014D4  0246 0007                497              ANDI.W      #$07,D6
000014D8  BC3C 0001                498              CMP.B       #$1,D6              ; Is instruction MOVEA?
000014DC  6600 001C                499              BNE         MOVEL               ; If not, it is MOVE
000014E0  14FC 0041                500              MOVE.B      #'A',(A2)+          ; Adds A to make MOVEA
000014E4  14FC 002E                501              MOVE.B      #'.',(A2)+
000014E8  14FC 004C                502              MOVE.B      #'L',(A2)+
000014EC  14FC 0020                503              MOVE.B      #' ',(A2)+
000014F0  14FC 0020                504              MOVE.B      #' ',(A2)+
000014F4  4EF9 00002074            505              JMP         GET_EA              ; Continue making source destination
000014FA  14FC 002E                506  MOVEL       MOVE.B      #'.',(A2)+
000014FE  14FC 004C                507              MOVE.B      #'L',(A2)+
00001502  14FC 0020                508              MOVE.B      #' ',(A2)+
00001506  14FC 0020                509              MOVE.B      #' ',(A2)+
0000150A  14FC 0020                510              MOVE.B      #' ',(A2)+  
0000150E  4EB9 00002074            511  MOVEL_EA    JSR         GET_EA              ; Prints desitination operand
00001514  14FC 002C                512              MOVE.B      #',',(A2)+          ; Adds comma between data
00001518  4EB9 00001E34            513              JSR         MOVE_SWAP           ; Swap the destination and source regs for GET_EA
0000151E  4EB9 00002074            514              JSR         GET_EA     
00001524  4E75                     515  END0010     RTS
00001526                           516   
00001526                           517   
00001526                           518  *--------------------------------------------------------------------------------------------------------------
00001526                           519  *   OPCODE: 0011 (MOVE.W, MOVEA.W)
00001526                           520  *-------------------------------------------------------------------------------------------------------------- 
00001526                           521  
00001526                           522  GROUP1_0011 
00001526  14FC 004D                523              MOVE.B      #'M',(A2)+          ; Puts MOVE/A.W into buffer
0000152A  14FC 004F                524              MOVE.B      #'O',(A2)+
0000152E  14FC 0056                525              MOVE.B      #'V',(A2)+
00001532  14FC 0045                526              MOVE.B      #'E',(A2)+
00001536  1C07                     527              MOVE.B      D7,D6               ; Copies instruction to shift
00001538  EC8E                     528              LSR.L       #6,D6               ; Shift by 6 bits
0000153A  0246 0007                529              ANDI.W      #$07,D6             
0000153E  BC3C 0001                530              CMP.B       #$1,D6              ; Is instruction MOVEA?
00001542  6600 001C                531              BNE         MOVEW               ; If not, it is MOVE
00001546  14FC 0041                532              MOVE.B      #'A',(A2)+          ; Adds A to make MOVEA
0000154A  14FC 002E                533              MOVE.B      #'.',(A2)+
0000154E  14FC 0057                534              MOVE.B      #'W',(A2)+
00001552  14FC 0020                535              MOVE.B      #' ',(A2)+
00001556  14FC 0020                536              MOVE.B      #' ',(A2)+
0000155A  4EF9 00001574            537              JMP         MOVEWEA             ; Continue making source destination
00001560  14FC 002E                538  MOVEW       MOVE.B      #'.',(A2)+
00001564  14FC 0057                539              MOVE.B      #'W',(A2)+
00001568  14FC 0020                540              MOVE.B      #' ',(A2)+
0000156C  14FC 0020                541              MOVE.B      #' ',(A2)+
00001570  14FC 0020                542              MOVE.B      #' ',(A2)+  
00001574  4EB9 00002074            543  MOVEWEA     JSR         GET_EA              ; Prints desitination operand
0000157A  14FC 002C                544              MOVE.B      #',',(A2)+          ; Adds comma between data
0000157E  4EB9 00001E34            545              JSR         MOVE_SWAP           ; Swap the destination and source regs for GET_EA 
00001584                           546  
00001584  4EB9 00002074            547              JSR         GET_EA     
0000158A  4E75                     548  END0011     RTS 
0000158C                           549  
0000158C                           550  
0000158C                           551  *--------------------------------------------------------------------------------------------------------------
0000158C                           552  *   OPCODE: 0100 (CLR, NEG, NOT, MOVEM, SWAP, JMP, JSR, NOP, RTS, LEA) *Continues to OP_TABLE4*
0000158C                           553  *--------------------------------------------------------------------------------------------------------------
0000158C                           554  
0000158C                           555  GROUP1_0100 
0000158C  3C07                     556              MOVE.W      D7,D6               ; Copies instruction to shift
0000158E  0246 0100                557              ANDI.W      #$0100,D6           ; Gets eighth bit of address
00001592  BC7C 0100                558              CMP.W       #$0100,D6           ; Is instruction LEA?
00001596  6700 0022                559              BEQ         OP_LEA              ; If yes, continue for LEA
0000159A  3C07                     560              MOVE.W      D7,D6               ; Copies instruction to shift
0000159C  183C 0008                561              MOVE.B      #08,D4              ; Assigns 8 bits to shift register
000015A0  E86E                     562              LSR.W       D4,D6               ; Shift instruction 8 bits left
000015A2  0246 000F                563              ANDI.W      #$000F,D6           ; Gets last 4 bits of address
000015A6  CCFC 0006                564              MULU        #6,D6               ; Forms offset for next JMP table
000015AA  4BF9 00001BF8            565              LEA         OP_TABLE4,A5        ; Loads next JMP table 
000015B0  4EB5 6000                566              JSR         00(A5,D6)           ; Jumps to next instruction per next 4 bits
000015B4  4EF9 000015EE            567              JMP         END0100             ; Skip to end once back from table
000015BA                           568              
000015BA  14FC 004C                569  OP_LEA      MOVE.B      #'L',(A2)+          ; Puts LEA into buffer
000015BE  14FC 0045                570              MOVE.B      #'E',(A2)+
000015C2  14FC 0041                571              MOVE.B      #'A',(A2)+
000015C6  14FC 0020                572              MOVE.B      #' ',(A2)+
000015CA  14FC 0009                573              MOVE.B      #$09,(A2)+ 
000015CE  4EB9 00002074            574              JSR         GET_EA              ; Determines address to go to buffer
000015D4  14FC 002C                575              MOVE.B      #',',(A2)+          ; Adds comma between data
000015D8  14FC 0041                576              MOVE.B      #'A',(A2)+          ; Adds A for address
000015DC  3C07                     577              MOVE.W      D7,D6               ; Copies instruction to shift
000015DE  183C 0009                578              MOVE.B      #9,D4               ; Assigns 9 bits to shift register
000015E2  E86E                     579              LSR.W       D4,D6               ; Shift instruction 9 bits left
000015E4  0246 000F                580              ANDI.W      #$000F,D6           ; Gets last 4 bits of address
000015E8  0606 0030                581              ADD.B       #$30,D6             ; convert D register # to hex
000015EC  14C6                     582              MOVE.B      D6,(A2)+            ; register # goes into buffer
000015EE  4E75                     583  END0100     RTS
000015F0                           584  
000015F0                           585  GROUP1_0101 
000015F0  4EB9 00001F16            586              JSR         INVALID_INST        ; Instruction becomes placeholder
000015F6  4E75                     587              RTS
000015F8                           588              
000015F8                           589  GROUP1_0110 
000015F8  4EB9 00001F16            590              JSR         INVALID_INST        ; For MOVEM
000015FE  5448                     591              ADDQ.W      #2,A0
00001600  4E75                     592              RTS
00001602                           593  
00001602                           594  GROUP1_0111 
00001602  4EB9 00001F16            595              JSR         INVALID_INST        ; Instruction becomes placeholder
00001608  4E75                     596              RTS
0000160A                           597              
0000160A                           598              
0000160A                           599  *--------------------------------------------------------------------------------------------------------------
0000160A                           600  *   OPCODE: 1000 (OR)
0000160A                           601  *-------------------------------------------------------------------------------------------------------------- 
0000160A                           602   
0000160A                           603  GROUP1_1000 
0000160A  3C07                     604              MOVE.W      D7,D6               ; Copies DIV instruction to shift
0000160C  EC8E                     605              LSR.L       #6,D6               ; Shift instruction 6 bits left
0000160E  0246 0003                606              ANDI.W      #$03,D6             ; Mask last 2 bits
00001612  BC3C 0003                607              CMP.B       #$3,D6              ; Is this instruction invalid?
00001616  6600 0008                608              BNE         OP_OR               ; If not, continue for OR
0000161A  4EF9 00001F16            609              JMP         INVALID_INST            
00001620                           610  
00001620  14FC 004F                611  OP_OR       MOVE.B      #'O',(A2)+          ; Puts OR into buffer
00001624  14FC 0052                612              MOVE.B      #'R',(A2)+
00001628  14FC 002E                613              MOVE.B      #'.',(A2)+            
0000162C  4EB9 00001DFE            614              JSR         FIND_SIZE           ; Decides whether B,W,L
00001632  14FC 0020                615              MOVE.B      #' ',(A2)+
00001636  14FC 0020                616              MOVE.B      #' ',(A2)+
0000163A  14FC 0020                617              MOVE.B      #' ',(A2)+
0000163E  14FC 0020                618              MOVE.B      #' ',(A2)+
00001642  14FC 0020                619              MOVE.B      #' ',(A2)+
00001646  4EB9 00001EF2            620              JSR         DIR_BIT             ; get Direction Bit 0 = EA 1 = regs
0000164C  BC3C 0000                621              CMP.B       #%0,D6              ; Is this EA first?
00001650  6600 001C                622              BNE         OP_OR01             ; If not, go to register mode first
00001654  4EB9 00002074            623              JSR         GET_EA              ; Print effective address
0000165A  14FC 002C                624              MOVE.B      #',',(A2)+          ; Adds comma between data
0000165E  14FC 0044                625              MOVE.B      #'D',(A2)+          ; Adds D for data register
00001662  4EB9 00001EE0            626              JSR         HIGH_ADD            ; Add register number to buffer
00001668  4EF9 00001682            627              JMP         END1000             ; Exit subroute 1000
0000166E                           628              
0000166E  14FC 0044                629  OP_OR01     MOVE.B      #'D',(A2)+          ; Adds D for data register
00001672  4EB9 00001EE0            630              JSR         HIGH_ADD            ; Add register number to buffer
00001678  14FC 002C                631              MOVE.B      #',',(A2)+          ; Adds comma between data
0000167C  4EB9 00002074            632              JSR         GET_EA              ; Insert EA        
00001682                           633  
00001682  4E75                     634  END1000     RTS
00001684                           635  
00001684                           636  
00001684                           637  *--------------------------------------------------------------------------------------------------------------
00001684                           638  *   OPCODE: 1001 (SUB, SUBA)
00001684                           639  *-------------------------------------------------------------------------------------------------------------- 
00001684                           640  
00001684                           641  GROUP1_1001 
00001684  14FC 0053                642              MOVE.B      #'S',(A2)+          ; Puts SUB into buffer
00001688  14FC 0055                643              MOVE.B      #'U',(A2)+
0000168C  14FC 0042                644              MOVE.B      #'B',(A2)+
00001690  4EB9 00001DF4            645              JSR         GET_SIZE            ; Gets size data and puts into D6
00001696  BC3C 0003                646              CMP.B       #%11,D6             ; Is instruction SUBA?
0000169A  6600 0028                647              BNE         OP_SUBA             ; If not, it is SUB
0000169E  14FC 0041                648              MOVE.B      #'A',(A2)+          ; Adds A to make SUBA
000016A2  14FC 002E                649              MOVE.B      #'.',(A2)+
000016A6  3C07                     650              MOVE.W      D7,D6               ; Copies instruction to shift
000016A8  E08E                     651              LSR.L       #08,D6              ; Shift instruction 6 bits left
000016AA  0246 0001                652              ANDI.W      #$0001,D6           ; Gets size bit
000016AE  BC3C 0001                653              CMP.B       #%1,D6              ; Compare to determine size
000016B2  6700 000C                654              BEQ         SUBAL               ; Goes to SUBAL if long
000016B6  14FC 0057                655              MOVE.B      #'W',(A2)+          ; Becomes word and enters buffer
000016BA  4EF9 000016C4            656              JMP         OP_SUBA
000016C0  14FC 004C                657  SUBAL       MOVE.B      #'L',(A2)+          ; Adds long to buffer           
000016C4  14FC 0020                658  OP_SUBA     MOVE.B      #' ',(A2)+
000016C8  14FC 0020                659              MOVE.B      #' ',(A2)+
000016CC  14FC 0020                660              MOVE.B      #' ',(A2)+
000016D0                           661  
000016D0  4EB9 00002074            662              JSR         GET_EA              ; Gets source operand
000016D6  14FC 002C                663              MOVE.B      #',',(A2)+          ; Adds comma between data
000016DA  14FC 0041                664              MOVE.B      #'A',(A2)+          ; Adds A for address
000016DE  4EB9 00001EE0            665              JSR         HIGH_ADD            ; Add register number to buffer
000016E4  4EF9 00001A70            666              JMP         END1101
000016EA                           667              
000016EA  14FC 002E                668  OP_SUB      MOVE.B      #'.',(A2)+
000016EE  4EB9 00001DFE            669              JSR         FIND_SIZE           ; Decides whether B,W,L
000016F4  14FC 0020                670              MOVE.B      #' ',(A2)+
000016F8  14FC 0020                671              MOVE.B      #' ',(A2)+
000016FC  14FC 0020                672              MOVE.B      #' ',(A2)+
00001700  14FC 0020                673              MOVE.B      #' ',(A2)+
00001704  4EB9 00001EF2            674              JSR         DIR_BIT             ; Get Direction Bit 0 = EA 1 = regs
0000170A  BC3C 0000                675              CMP.B       #%0,D6              ; Is this EA first?
0000170E  6600 001C                676              BNE         OP_SUB01            ; If not, go to register mode first
00001712  4EB9 00002074            677              JSR         GET_EA              ; Print effective address
00001718  14FC 002C                678              MOVE.B      #',',(A2)+          ; Adds comma between data
0000171C  14FC 0044                679              MOVE.B      #'D',(A2)+          ; Adds D for data register
00001720  4EB9 00001EE0            680              JSR         HIGH_ADD            ; Add register number to buffer
00001726  4EF9 00001740            681              JMP         END1001             ; Exit subroute 1001
0000172C                           682              
0000172C  14FC 0044                683  OP_SUB01    MOVE.B      #'D',(A2)+          ; Adds D for data register
00001730  4EB9 00001EE0            684              JSR         HIGH_ADD            ; Add register number to buffer
00001736  14FC 002C                685              MOVE.B      #',',(A2)+          ; Adds comma between data
0000173A  4EB9 00002074            686              JSR         GET_EA              ; Insert EA          
00001740                           687              
00001740  4E75                     688  END1001     RTS            
00001742                           689  
00001742                           690  GROUP1_1010 
00001742  4EB9 00001F16            691              JSR         INVALID_INST        ; Instruction  is invalid
00001748  4E75                     692              RTS
0000174A                           693  
0000174A                           694  
0000174A                           695  *--------------------------------------------------------------------------------------------------------------
0000174A                           696  *   OPCODE: 1011 (CMP, CMPA, EOR)
0000174A                           697  *-------------------------------------------------------------------------------------------------------------- 
0000174A                           698  
0000174A                           699  GROUP1_1011 
0000174A  4EB9 00001DF4            700              JSR         GET_SIZE            ; Gets size data and puts into D6
00001750  BC3C 0003                701              CMP.B       #%11,D6             ; Is instruction CMPA?
00001754  6600 005A                702              BNE         OP_CMPEOR           ; If not, it is EOR
00001758  14FC 0043                703              MOVE.B      #'C',(A2)+          ; Puts CMPA into buffer
0000175C  14FC 004D                704              MOVE.B      #'M',(A2)+
00001760  14FC 0050                705              MOVE.B      #'P',(A2)+
00001764  14FC 0041                706              MOVE.B      #'A',(A2)+
00001768  14FC 002E                707              MOVE.B      #'.',(A2)+
0000176C  3C07                     708              MOVE.W      D7,D6               ; Copies instruction to shift
0000176E  E08E                     709              LSR.L       #08,D6              ; Gets eighth bit of address
00001770  0246 0001                710              ANDI.W      #$0001,D6           ; Gets size bit
00001774  BC3C 0001                711              CMP.B       #%1,D6              ; Compare to determine size
00001778  6700 000C                712              BEQ         CMPAL               ; Goes to CMPAL if long
0000177C  14FC 0057                713              MOVE.B      #'W',(A2)+          ; Becomes word and enters buffer
00001780  4EF9 0000178A            714              JMP         OP_CMPA
00001786  14FC 004C                715  CMPAL       MOVE.B      #'L',(A2)+          ; Adds long to buffer           
0000178A  14FC 0020                716  OP_CMPA     MOVE.B      #' ',(A2)+
0000178E  14FC 0020                717              MOVE.B      #' ',(A2)+          
00001792  14FC 0020                718              MOVE.B      #' ',(A2)+
00001796                           719  
00001796  4EB9 00002074            720              JSR         GET_EA              ; Gets source operand
0000179C  14FC 002C                721              MOVE.B      #',',(A2)+          ; Adds comma between data
000017A0  14FC 0041                722              MOVE.B      #'A',(A2)+          ; Adds A for address
000017A4  4EB9 00001EE0            723              JSR         HIGH_ADD            ; Add register number to buffer
000017AA  4EF9 0000183A            724              JMP         END1011
000017B0                           725              
000017B0  3C07                     726  OP_CMPEOR   MOVE.W      D7,D6               ; Get new instruction
000017B2  4EB9 00001EF2            727              JSR         DIR_BIT             ; Get Direction Bit 1 = eor 0 = cmp
000017B8  BC3C 0000                728              CMP.B       #%0,D6              ; Is this EA first?
000017BC  6600 0042                729              BNE         OP_EOR              ; If not, go to register mode first            
000017C0                           730                     
000017C0  14FC 0043                731  OP_CMP      MOVE.B      #'C',(A2)+          ; Puts CMP into buffer
000017C4  14FC 004D                732              MOVE.B      #'M',(A2)+
000017C8  14FC 0050                733              MOVE.B      #'P',(A2)+
000017CC  14FC 002E                734              MOVE.B      #'.',(A2)+
000017D0  4EB9 00001DFE            735              JSR         FIND_SIZE           ; Decides whether B,W,L
000017D6  14FC 0020                736              MOVE.B      #' ',(A2)+
000017DA  14FC 0020                737              MOVE.B      #' ',(A2)+
000017DE  14FC 0020                738              MOVE.B      #' ',(A2)+
000017E2  14FC 0020                739              MOVE.B      #' ',(A2)+
000017E6  4EB9 00002074            740              JSR         GET_EA              ; Gets source operand
000017EC  14FC 002C                741              MOVE.B      #',',(A2)+          ; Adds comma between data
000017F0  14FC 0044                742              MOVE.B      #'D',(A2)+          ; Adds D for data register
000017F4  4EB9 00001EE0            743              JSR         HIGH_ADD            ; Add register number to buffer
000017FA  4EF9 0000183A            744              JMP         END1011             ; Exit subroute 1011
00001800                           745        
00001800                           746                          
00001800  14FC 0045                747  OP_EOR      MOVE.B      #'E',(A2)+          ; Puts EOR into buffer
00001804  14FC 004F                748              MOVE.B      #'O',(A2)+
00001808  14FC 0052                749              MOVE.B      #'R',(A2)+
0000180C  14FC 002E                750              MOVE.B      #'.',(A2)+
00001810  4EB9 00001DFE            751              JSR         FIND_SIZE           ; Decides whether B,W,L
00001816  14FC 0020                752              MOVE.B      #' ',(A2)+
0000181A  14FC 0020                753              MOVE.B      #' ',(A2)+
0000181E  14FC 0020                754              MOVE.B      #' ',(A2)+
00001822  14FC 0020                755              MOVE.B      #' ',(A2)+
00001826  14FC 0044                756              MOVE.B      #'D',(A2)+          ; Adds D for data register
0000182A  4EB9 00001EE0            757              JSR         HIGH_ADD            ; Add register number to buffer            
00001830  14FC 002C                758              MOVE.B      #',',(A2)+          ; Adds comma between data
00001834  4EB9 00002074            759              JSR         GET_EA              ; Insert EA     
0000183A                           760                               
0000183A  4E75                     761  END1011     RTS
0000183C                           762  
0000183C                           763  
0000183C                           764  *--------------------------------------------------------------------------------------------------------------
0000183C                           765  *   OPCODE: 1100 (EXG, AND)
0000183C                           766  *-------------------------------------------------------------------------------------------------------------- 
0000183C                           767  
0000183C                           768  GROUP1_1100 
0000183C  3C07                     769              MOVE.W      D7,D6               ; Copies instruction to shift
0000183E  EC8E                     770  OP_MULU     LSR.L       #6,D6               ; Shift instruction 6 bits left
00001840  0246 0003                771              ANDI.W      #$3,D6              ; Mask last 3 bits
00001844  BC3C 0003                772              CMP.B       #$3,D6              ; Is instruction MULU or MULS?
00001848  6700 0008                773              BEQ         MULU_MODE           ; If yes, continue for MULU to determine immediate   
0000184C  4EF9 00001870            774              JMP         OP_ANDEXG           ; If no, go to OP_ANDEXG
00001852  3C07                     775  MULU_MODE   MOVE.W      D7,D6               ; Get new instruction
00001854  E68E                     776              LSR.L       #3,D6               ; Shift instruction 3 bits left
00001856  0246 0007                777              ANDI.W      #$7,D6              ; Mask last mode bits
0000185A  BC3C 0007                778              CMP.B       #$7,D6
0000185E  6700 0008                779              BEQ         MOVE_PTR            ; Have pointer go by word
00001862  4EF9 00001F16            780              JMP         INVALID_INST        ; Invalid instruction
00001868                           781  
00001868  5448                     782  MOVE_PTR    ADDQ.W      #2,A0               ; Increment pointer
0000186A  4EF9 00001F16            783              JMP         INVALID_INST        ; Invalid instruction
00001870                           784          
00001870  3C07                     785  OP_ANDEXG   MOVE.W      D7,D6               ; Copies EXG and AND instruction to shift         
00001872  E68E                     786              LSR.L       #3,D6               ; Shift instruction 3 bits left
00001874  0206 001F                787              ANDI.B      #$1F,D6             ; Mask last 5 bits
00001878  BC3C 0008                788              CMP.B       #$08,D6             ; Is instruction EXG D to D?
0000187C  6700 007A                789              BEQ         OP_EXGd2d           ; If yes, go to OP_EXGd2d
00001880  BC3C 0009                790              CMP.B       #$09,D6             ; Is instruction EXG A to A?
00001884  6700 00B0                791              BEQ         OP_EXGa2a           ; If yes, go to OP_EXGa2a
00001888  BC3C 0011                792              CMP.B       #$11,D6             ; Is instruction EXG D to A?
0000188C  6700 00E6                793              BEQ         OP_EXGd2a           ; If yes, go to OP_EXGd2a
00001890                           794              
00001890                           795              
00001890  14FC 0041                796  OP_AND      MOVE.B      #'A',(A2)+          ; Puts AND into buffer
00001894  14FC 004E                797              MOVE.B      #'N',(A2)+
00001898  14FC 0044                798              MOVE.B      #'D',(A2)+
0000189C  14FC 002E                799              MOVE.B      #'.',(A2)+            
000018A0  4EB9 00001DFE            800              JSR         FIND_SIZE           ; Decides whether B,W,L
000018A6  14FC 0020                801              MOVE.B      #' ',(A2)+
000018AA  14FC 0020                802              MOVE.B      #' ',(A2)+
000018AE  14FC 0020                803              MOVE.B      #' ',(A2)+
000018B2  14FC 0020                804              MOVE.B      #' ',(A2)+
000018B6  4EB9 00001EF2            805              JSR         DIR_BIT             ; Get Direction Bit 0 = EA 1 =regs
000018BC  BC3C 0000                806              CMP.B       #%0,D6              ; Is this EA first?
000018C0  6600 001C                807              BNE         OP_AND01            ; If not, go to register mode first
000018C4  4EB9 00002074            808              JSR         GET_EA              ; Print EA
000018CA  14FC 002C                809              MOVE.B      #',',(A2)+          ; Adds comma between data
000018CE  14FC 0044                810              MOVE.B      #'D',(A2)+          ; Adds D for data register
000018D2  4EB9 00001EE0            811              JSR         HIGH_ADD            ; Add register number to buffer
000018D8  4EF9 000019B2            812              JMP         END1100             ; Exit subroute 1100
000018DE                           813              
000018DE  14FC 0044                814  OP_AND01    MOVE.B      #'D',(A2)+          ; Adds D for data register
000018E2  4EB9 00001EE0            815              JSR         HIGH_ADD            ; Add register number to buffer
000018E8  14FC 002C                816              MOVE.B      #',',(A2)+          ; Adds comma between data
000018EC  4EB9 00002074            817              JSR         GET_EA              ; Insert EA                   
000018F2  4EF9 000019B2            818              JMP         END1100
000018F8                           819  
000018F8  14FC 0045                820  OP_EXGd2d   MOVE.B      #'E',(A2)+          ; Puts EXG D to D into buffer
000018FC  14FC 0058                821              MOVE.B      #'X',(A2)+           
00001900  14FC 0047                822              MOVE.B      #'G',(A2)+
00001904  14FC 0020                823              MOVE.B      #' ',(A2)+
00001908  14FC 0020                824              MOVE.B      #' ',(A2)+
0000190C  14FC 0020                825              MOVE.B      #' ',(A2)+
00001910  14FC 0020                826              MOVE.B      #' ',(A2)+
00001914  14FC 0020                827              MOVE.B      #' ',(A2)+
00001918  14FC 0020                828              MOVE.B      #' ',(A2)+
0000191C  14FC 0044                829              MOVE.B      #'D',(A2)+          ; Put D reg, then D reg
00001920  4EB9 00001EE0            830              JSR         HIGH_ADD            ; Add register number to buffer
00001926  14FC 002C                831              MOVE.B      #',',(A2)+          ; Adds comma between data
0000192A  4EB9 00002074            832              JSR         GET_EA              ; Get Destination register
00001930  4EF9 000019B2            833              JMP         END1100             ; Exit subroute 1011
00001936                           834                          
00001936  14FC 0045                835  OP_EXGa2a   MOVE.B      #'E',(A2)+          ; Puts EXG A to A into buffer
0000193A  14FC 0058                836              MOVE.B      #'X',(A2)+           
0000193E  14FC 0047                837              MOVE.B      #'G',(A2)+
00001942  14FC 0020                838              MOVE.B      #' ',(A2)+
00001946  14FC 0020                839              MOVE.B      #' ',(A2)+
0000194A  14FC 0020                840              MOVE.B      #' ',(A2)+
0000194E  14FC 0020                841              MOVE.B      #' ',(A2)+
00001952  14FC 0020                842              MOVE.B      #' ',(A2)+
00001956  14FC 0020                843              MOVE.B      #' ',(A2)+
0000195A  14FC 0041                844              MOVE.B      #'A',(A2)+          ; Put A reg, then A reg
0000195E  4EB9 00001EE0            845              JSR         HIGH_ADD            ; Add register number to buffer
00001964  14FC 002C                846              MOVE.B      #',',(A2)+          ; Adds comma between data
00001968  4EB9 00002074            847              JSR         GET_EA              ; Get Destination register
0000196E  4EF9 000019B2            848              JMP         END1100             ; Exit subroute 1011
00001974                           849              
00001974  14FC 0045                850  OP_EXGd2a   MOVE.B      #'E',(A2)+          ; Puts EXG D to A into buffer
00001978  14FC 0058                851              MOVE.B      #'X',(A2)+           
0000197C  14FC 0047                852              MOVE.B      #'G',(A2)+
00001980  14FC 0020                853              MOVE.B      #' ',(A2)+
00001984  14FC 0020                854              MOVE.B      #' ',(A2)+
00001988  14FC 0020                855              MOVE.B      #' ',(A2)+
0000198C  14FC 0020                856              MOVE.B      #' ',(A2)+
00001990  14FC 0020                857              MOVE.B      #' ',(A2)+
00001994  14FC 0020                858              MOVE.B      #' ',(A2)+
00001998  14FC 0044                859              MOVE.B      #'D',(A2)+          ; Put D reg, then A reg
0000199C  4EB9 00001EE0            860              JSR         HIGH_ADD            ; Add register number to buffer
000019A2  14FC 002C                861              MOVE.B      #',',(A2)+          ; Adds comma between data
000019A6  4EB9 00002074            862              JSR         GET_EA              ; Get Destination register
000019AC  4EF9 000019B2            863              JMP         END1100             ; Exit subroute 1011
000019B2                           864  
000019B2  4E75                     865  END1100     RTS
000019B4                           866  
000019B4                           867  
000019B4                           868  *--------------------------------------------------------------------------------------------------------------
000019B4                           869  *   OPCODE: 1101 (ADD,ADDA)
000019B4                           870  *-------------------------------------------------------------------------------------------------------------- 
000019B4                           871  
000019B4                           872  GROUP1_1101 
000019B4  14FC 0041                873              MOVE.B      #'A',(A2)+          ; Puts ADD into buffer
000019B8  14FC 0044                874              MOVE.B      #'D',(A2)+
000019BC  14FC 0044                875              MOVE.B      #'D',(A2)+
000019C0  4EB9 00001DF4            876              JSR         GET_SIZE            ; Gets size data and puts into D6
000019C6  BC3C 0003                877              CMP.B       #%11,D6             ; Is instruction ADDA?
000019CA  6600 004E                878              BNE         OP_ADD              ; If not, it is ADD
000019CE  14FC 0041                879              MOVE.B      #'A',(A2)+          ; Adds A to make ADDA
000019D2  14FC 002E                880              MOVE.B      #'.',(A2)+
000019D6  3C07                     881              MOVE.W      D7,D6               ; Get new instruction
000019D8  E08E                     882              LSR.L       #08,D6              ; Gets eighth bit of address
000019DA  0246 0001                883              ANDI.W      #$0001,D6           ; Gets size bit
000019DE  BC3C 0001                884              CMP.B       #%1,D6              ; Compare to determine size
000019E2  6700 000C                885              BEQ         ADDAL               ; Goes to ADDAL if long
000019E6  14FC 0057                886              MOVE.B      #'W',(A2)+          ; Becomes word and enters buffer
000019EA  4EF9 000019F4            887              JMP         OP_ADDA
000019F0  14FC 004C                888  ADDAL       MOVE.B      #'L',(A2)+          ; Adds long to buffer          
000019F4  14FC 0020                889  OP_ADDA     MOVE.B      #' ',(A2)+
000019F8  14FC 0020                890              MOVE.B      #' ',(A2)+
000019FC  14FC 0020                891              MOVE.B      #' ',(A2)+
00001A00                           892              
00001A00  4EB9 00002074            893              JSR         GET_EA              ; Gets source operand
00001A06  14FC 002C                894              MOVE.B      #',',(A2)+          ; Adds comma between data
00001A0A  14FC 0041                895              MOVE.B      #'A',(A2)+          ; Adds A for address register
00001A0E  4EB9 00001EE0            896              JSR         HIGH_ADD            ; Add register number to buffer
00001A14  4EF9 00001A70            897              JMP         END1101
00001A1A                           898              
00001A1A  14FC 002E                899  OP_ADD      MOVE.B      #'.',(A2)+
00001A1E  4EB9 00001DFE            900              JSR         FIND_SIZE           ; Decides whether B,W,L
00001A24  14FC 0020                901              MOVE.B      #' ',(A2)+
00001A28  14FC 0020                902              MOVE.B      #' ',(A2)+
00001A2C  14FC 0020                903              MOVE.B      #' ',(A2)+
00001A30  14FC 0020                904              MOVE.B      #' ',(A2)+
00001A34  4EB9 00001EF2            905              JSR         DIR_BIT             ; Get Direction Bit 0 = EA 1 =regs
00001A3A  BC3C 0000                906              CMP.B       #%0,D6              ; Is this EA first?
00001A3E  6600 001C                907              BNE         OP_ADD01            ; If not, go to register mode first
00001A42  4EB9 00002074            908              JSR         GET_EA              ; Print EA
00001A48  14FC 002C                909              MOVE.B      #',',(A2)+          ; Adds comma between data
00001A4C  14FC 0044                910              MOVE.B      #'D',(A2)+          ; Adds D for data register
00001A50  4EB9 00001EE0            911              JSR         HIGH_ADD            ; Add register number to buffer
00001A56  4EF9 00001A70            912              JMP         END1101             ; Exit subroute 1101
00001A5C                           913              
00001A5C  14FC 0044                914  OP_ADD01    MOVE.B      #'D',(A2)+          ; Adds D for data register
00001A60  4EB9 00001EE0            915              JSR         HIGH_ADD            ; Add register number to buffer
00001A66  14FC 002C                916              MOVE.B      #',',(A2)+          ; Adds comma between data
00001A6A  4EB9 00002074            917              JSR         GET_EA              ; Get Destination register
00001A70                           918  
00001A70  4E75                     919  END1101     RTS
00001A72                           920  
00001A72                           921  
00001A72                           922  *--------------------------------------------------------------------------------------------------------------
00001A72                           923  *   OPCODE: 1110 (ASd, LSd, ROd)
00001A72                           924  *-------------------------------------------------------------------------------------------------------------- 
00001A72                           925  
00001A72                           926  GROUP1_1110 
00001A72  4EB9 00001DF4            927              JSR         GET_SIZE            ; Gets size data and puts into D6
00001A78  BC3C 0003                928              CMP.B       #%11,D6             ; Is instruction ASd, LSd, ROd?
00001A7C  6700 00BE                929              BEQ         OP_ShMem
00001A80  3C07                     930  OP_SHIFT    MOVE.W      D7,D6               ; Copies instruction to shift
00001A82  E60E                     931              LSR.B       #3,D6               ; Shift instruction 3 bits left
00001A84  0206 0003                932              ANDI.B      #$03,D6             ; Mask bits
00001A88  BC3C 0000                933              CMP.B       #%00,D6             ; Is instruction AS(d)?
00001A8C  6700 0046                934              BEQ         OP_ASd              ; If yes, go to AS
00001A90  BC3C 0001                935              CMP.B       #%01,D6             ; Is instruction LS(d)?
00001A94  6700 0072                936              BEQ         OP_LSd              ; If yes, go to LS
00001A98  BC3C 0003                937              CMP.B       #%11,D6             ; Is instruction RO(d)?
00001A9C  6600 0478                938              BNE         INVALID_INST        ; If no, invalid instruction
00001AA0  14FC 0052                939  OP_ROd      MOVE.B      #'R',(A2)+          ; Puts RO into buffer
00001AA4  14FC 004F                940              MOVE.B      #'O',(A2)+          
00001AA8  4EB9 00001E88            941              JSR         GET_DIR             ; Adds direction to buffer
00001AAE  14FC 002E                942              MOVE.B      #'.',(A2)+
00001AB2  4EB9 00001DFE            943              JSR         FIND_SIZE           ; Decides whether B,W,L
00001AB8  14FC 0020                944              MOVE.B      #' ',(A2)+
00001ABC  14FC 0020                945              MOVE.B      #' ',(A2)+
00001AC0  14FC 0020                946              MOVE.B      #' ',(A2)+
00001AC4  14FC 0020                947              MOVE.B      #' ',(A2)+
00001AC8  4EB9 00001EA6            948              JSR         GET_IR              ; Determine register and EA
00001ACE  4EF9 00001BEE            949              JMP         END1110 
00001AD4                           950      
00001AD4  14FC 0041                951  OP_ASd      MOVE.B      #'A',(A2)+          ; Puts AS into buffer
00001AD8  14FC 0053                952              MOVE.B      #'S',(A2)+          
00001ADC  4EB9 00001E88            953              JSR         GET_DIR             ; Adds direction to buffer
00001AE2  14FC 002E                954              MOVE.B      #'.',(A2)+
00001AE6  4EB9 00001DFE            955              JSR         FIND_SIZE           ; Decides whether B,W,L
00001AEC  14FC 0020                956              MOVE.B      #' ',(A2)+
00001AF0  14FC 0020                957              MOVE.B      #' ',(A2)+
00001AF4  14FC 0020                958              MOVE.B      #' ',(A2)+
00001AF8  14FC 0020                959              MOVE.B      #' ',(A2)+
00001AFC  4EB9 00001EA6            960              JSR         GET_IR              ; Determine register and EA
00001B02  4EF9 00001BEE            961              JMP         END1110     
00001B08                           962  
00001B08  14FC 004C                963  OP_LSd      MOVE.B      #'L',(A2)+          ; Puts LS into buffer
00001B0C  14FC 0053                964              MOVE.B      #'S',(A2)+          
00001B10  4EB9 00001E88            965              JSR         GET_DIR             ; Adds direction to buffer
00001B16  14FC 002E                966              MOVE.B      #'.',(A2)+
00001B1A  4EB9 00001DFE            967              JSR         FIND_SIZE           ; Decides whether B,W,L
00001B20  14FC 0020                968              MOVE.B      #' ',(A2)+
00001B24  14FC 0020                969              MOVE.B      #' ',(A2)+
00001B28  14FC 0020                970              MOVE.B      #' ',(A2)+
00001B2C  14FC 0020                971              MOVE.B      #' ',(A2)+
00001B30  4EB9 00001EA6            972              JSR         GET_IR              ; Determine register and EA
00001B36  4EF9 00001BEE            973              JMP         END1110     
00001B3C                           974  
00001B3C  3C07                     975  OP_ShMem    MOVE.W      D7,D6               ; Copies instruction to shift
00001B3E  E08E                     976              LSR.L       #08,D6              ; Shift instruction 8 bits left
00001B40  E28E                     977              LSR.L       #1,D6               ; Shift instruction 1 extra to total 9
00001B42  0246 0007                978              ANDI.W      #$0007,D6           ; Get bits 9-11
00001B46  BC3C 0000                979              CMP.B       #%00,D6             ; Is this AS?
00001B4A  6700 0044                980              BEQ         OP_ASm              ; If yes, go to AS location
00001B4E  BC3C 0001                981              CMP.B       #%01,D6             ; Is this LS?
00001B52  6700 006E                982              BEQ         OP_LSm              ; If yes, go to LS location
00001B56  BC3C 0003                983              CMP.B       #%11,D6             ; Is this RO?
00001B5A  6600 03BA                984              BNE         INVALID_INST        ; If no, invalid instruction
00001B5E                           985              
00001B5E  14FC 0052                986  OP_ROm      MOVE.B      #'R',(A2)+          ; Start RO opcode location
00001B62  14FC 004F                987              MOVE.B      #'O',(A2)+          
00001B66  4EB9 00001E88            988              JSR         GET_DIR             ; Adds direction to buffer
00001B6C  14FC 002E                989              MOVE.B      #'.',(A2)+
00001B70  14FC 0057                990              MOVE.B      #'W',(A2)+          ; Size is word for memory shift
00001B74  14FC 0020                991              MOVE.B      #' ',(A2)+
00001B78  14FC 0020                992              MOVE.B      #' ',(A2)+
00001B7C  14FC 0020                993              MOVE.B      #' ',(A2)+
00001B80  14FC 0020                994              MOVE.B      #' ',(A2)+
00001B84  4EB9 00002074            995              JSR         GET_EA              ; Insert EA 
00001B8A  4EF9 00001BEE            996              JMP         END1110             ; Exit subroute 1110
00001B90                           997              
00001B90  14FC 0041                998  OP_ASm      MOVE.B      #'A',(A2)+          ; Start AS opcode location
00001B94  14FC 0053                999              MOVE.B      #'S',(A2)+          
00001B98  4EB9 00001E88           1000              JSR         GET_DIR             ; Adds direction to buffer
00001B9E  14FC 002E               1001              MOVE.B      #'.',(A2)+
00001BA2  14FC 0057               1002              MOVE.B      #'W',(A2)+          ; Size is word for memory shift
00001BA6  14FC 0020               1003              MOVE.B      #' ',(A2)+ 
00001BAA  14FC 0020               1004              MOVE.B      #' ',(A2)+
00001BAE  14FC 0020               1005              MOVE.B      #' ',(A2)+
00001BB2  14FC 0020               1006              MOVE.B      #' ',(A2)+
00001BB6  4EB9 00002074           1007              JSR         GET_EA              ; Insert EA 
00001BBC  4EF9 00001BEE           1008              JMP         END1110             ; Exit subroute 1110
00001BC2                          1009  
00001BC2  14FC 004C               1010  OP_LSm      MOVE.B      #'L',(A2)+          ; Start AS opcode location
00001BC6  14FC 0053               1011              MOVE.B      #'S',(A2)+          
00001BCA  4EB9 00001E88           1012              JSR         GET_DIR             ; Adds direction to buffer
00001BD0  14FC 002E               1013              MOVE.B      #'.',(A2)+
00001BD4  14FC 0057               1014              MOVE.B      #'W',(A2)+          ; Size is word for memory shift
00001BD8  14FC 0020               1015              MOVE.B      #' ',(A2)+
00001BDC  14FC 0020               1016              MOVE.B      #' ',(A2)+
00001BE0  14FC 0020               1017              MOVE.B      #' ',(A2)+
00001BE4  14FC 0020               1018              MOVE.B      #' ',(A2)+
00001BE8  4EB9 00002074           1019              JSR         GET_EA              ; Insert EA         
00001BEE  4E75                    1020  END1110     RTS
00001BF0                          1021  
00001BF0                          1022  
00001BF0                          1023    
00001BF0                          1024  
00001BF0                          1025              
00001BF0                          1026  GROUP1_1111 
00001BF0  4EB9 00001F16           1027              JSR         INVALID_INST        ; Instruction  is invalid
00001BF6  4E75                    1028              RTS
00001BF8                          1029  
00001BF8                          1030  
00001BF8                          1031  *--------------------------------------------------------------------------------------------------------------
00001BF8                          1032  *   SECOND OPCODE TABLE (4xxx opcodes)
00001BF8                          1033  *--------------------------------------------------------------------------------------------------------------
00001BF8                          1034   
00001BF8                          1035  OP_TABLE4
00001BF8  4EF9 00001C58           1036              JMP         GROUP4_0000            
00001BFE  4EF9 00001C60           1037              JMP         GROUP4_0001            
00001C04  4EF9 00001C68           1038              JMP         GROUP4_0010
00001C0A  4EF9 00001C96           1039              JMP         GROUP4_0011
00001C10  4EF9 00001C9E           1040              JMP         GROUP4_0100
00001C16  4EF9 00001CCC           1041              JMP         GROUP4_0101
00001C1C  4EF9 00001CD4           1042              JMP         GROUP4_0110
00001C22  4EF9 00001D02           1043              JMP         GROUP4_0111
00001C28  4EF9 00001D0A           1044              JMP         GROUP4_1000
00001C2E  4EF9 00001D48           1045              JMP         GROUP4_1001
00001C34  4EF9 00001D50           1046              JMP         GROUP4_1010
00001C3A  4EF9 00001D58           1047              JMP         GROUP4_1011
00001C40  4EF9 00001D60           1048              JMP         GROUP4_1100
00001C46  4EF9 00001D68           1049              JMP         GROUP4_1101
00001C4C  4EF9 00001D78           1050              JMP         GROUP4_1110
00001C52  4EF9 00001D70           1051              JMP         GROUP4_1111
00001C58                          1052              
00001C58                          1053  GROUP4_0000 
00001C58  4EB9 00001F16           1054              JSR         INVALID_INST        ; Instruction  is invalid
00001C5E  4E75                    1055              RTS
00001C60                          1056              
00001C60                          1057  GROUP4_0001 
00001C60  4EB9 00001F16           1058              JSR         INVALID_INST        ; Instruction  is invalid
00001C66  4E75                    1059              RTS
00001C68                          1060              
00001C68                          1061  GROUP4_0010 
00001C68  14FC 0043               1062              MOVE.B      #'C',(A2)+          ; Puts CLR into buffer
00001C6C  14FC 004C               1063              MOVE.B      #'L',(A2)+
00001C70  14FC 0052               1064              MOVE.B      #'R',(A2)+
00001C74  14FC 002E               1065              MOVE.B      #'.',(A2)+
00001C78  4EB9 00001DFE           1066              JSR         FIND_SIZE           ; Decides whether B,W,L
00001C7E  14FC 0020               1067              MOVE.B      #' ',(A2)+
00001C82  14FC 0020               1068              MOVE.B      #' ',(A2)+
00001C86  14FC 0020               1069              MOVE.B      #' ',(A2)+
00001C8A  14FC 0020               1070              MOVE.B      #' ',(A2)+         
00001C8E  4EB9 00002074           1071              JSR         GET_EA              ; Insert EA
00001C94  4E75                    1072              RTS
00001C96                          1073              
00001C96                          1074  GROUP4_0011 
00001C96  4EB9 00001F16           1075              JSR         INVALID_INST        ; Instruction  is invalid
00001C9C  4E75                    1076              RTS
00001C9E                          1077                            
00001C9E                          1078  GROUP4_0100 
00001C9E  14FC 004E               1079              MOVE.B      #'N',(A2)+          ; Puts NEG into buffer
00001CA2  14FC 0045               1080              MOVE.B      #'E',(A2)+
00001CA6  14FC 0047               1081              MOVE.B      #'G',(A2)+
00001CAA  14FC 002E               1082              MOVE.B      #'.',(A2)+
00001CAE  4EB9 00001DFE           1083              JSR         FIND_SIZE           ; Decides whether B,W,L
00001CB4  14FC 0020               1084              MOVE.B      #' ',(A2)+
00001CB8  14FC 0020               1085              MOVE.B      #' ',(A2)+
00001CBC  14FC 0020               1086              MOVE.B      #' ',(A2)+
00001CC0  14FC 0020               1087              MOVE.B      #' ',(A2)+         
00001CC4  4EB9 00002074           1088              JSR         GET_EA              ; Insert EA
00001CCA  4E75                    1089              RTS
00001CCC                          1090              
00001CCC                          1091  GROUP4_0101 
00001CCC  4EB9 00001F16           1092              JSR         INVALID_INST        ; Instruction  is invalid
00001CD2  4E75                    1093              RTS
00001CD4                          1094              
00001CD4                          1095  GROUP4_0110 
00001CD4  14FC 004E               1096              MOVE.B      #'N',(A2)+          ; Puts NOT into buffer
00001CD8  14FC 004F               1097              MOVE.B      #'O',(A2)+
00001CDC  14FC 0054               1098              MOVE.B      #'T',(A2)+
00001CE0  14FC 002E               1099              MOVE.B      #'.',(A2)+
00001CE4  4EB9 00001DFE           1100              JSR         FIND_SIZE           ; Decides whether B,W,L
00001CEA  14FC 0020               1101              MOVE.B      #' ',(A2)+
00001CEE  14FC 0020               1102              MOVE.B      #' ',(A2)+
00001CF2  14FC 0020               1103              MOVE.B      #' ',(A2)+
00001CF6  14FC 0020               1104              MOVE.B      #' ',(A2)+         
00001CFA  4EB9 00002074           1105              JSR         GET_EA              ; Insert EA      
00001D00  4E75                    1106              RTS
00001D02                          1107              
00001D02                          1108  GROUP4_0111 
00001D02  4EB9 00001F16           1109              JSR         INVALID_INST        ; Instruction  is invalid
00001D08  4E75                    1110              RTS
00001D0A                          1111              
00001D0A                          1112  
00001D0A                          1113  *--------------------------------------------------------------------------------------------------------------
00001D0A                          1114  *   OPCODE: 0100 1000 (SWAP,MOVEM)
00001D0A                          1115  *-------------------------------------------------------------------------------------------------------------- 
00001D0A                          1116  
00001D0A                          1117  GROUP4_1000 
00001D0A  3C07                    1118              MOVE.W      D7,D6               ; Get new instruction
00001D0C  E88E                    1119              LSR.L       #04,D6              ; Shift instruction by 4 bits
00001D0E  0246 000F               1120              ANDI.W      #$000F,D6           ; Get last byte
00001D12  BC3C 0004               1121              CMP.B       #$4,D6              ; Is instruction SWAP?
00001D16  6600 0028               1122              BNE         OP_MOVEM            ; If no, it is MOVEM
00001D1A  14FC 0053               1123              MOVE.B      #'S',(A2)+          ; Puts SWAP into buffer
00001D1E  14FC 0057               1124              MOVE.B      #'W',(A2)+
00001D22  14FC 0041               1125              MOVE.B      #'A',(A2)+
00001D26  14FC 0050               1126              MOVE.B      #'P',(A2)+
00001D2A  14FC 0009               1127              MOVE.B      #$09,(A2)+
00001D2E  14FC 0044               1128              MOVE.B      #'D',(A2)+          ; Adds D for data register
00001D32  3C07                    1129              MOVE.W      D7,D6               ; Get new instruction
00001D34  0246 000F               1130              ANDI.W      #$000F,D6           ; Get last byte
00001D38  0606 0030               1131              ADD.B       #$30,D6             ; Convert shift register to ASCII
00001D3C  14C6                    1132              MOVE.B      D6,(A2)+            ; Puts reg number into buffer
00001D3E                          1133  
00001D3E  4E75                    1134              RTS            
00001D40                          1135  
00001D40  4EB9 00001F16           1136  OP_MOVEM    JSR         INVALID_INST        ; Instruction  is invalid
00001D46  4E75                    1137              RTS   
00001D48                          1138  
00001D48                          1139  GROUP4_1001 
00001D48  4EB9 00001F16           1140              JSR         INVALID_INST        ; Instruction  is invalid
00001D4E  4E75                    1141              RTS   
00001D50                          1142  GROUP4_1010 
00001D50  4EB9 00001F16           1143              JSR         INVALID_INST        ; Instruction  is invalid
00001D56  4E75                    1144              RTS   
00001D58                          1145  GROUP4_1011 
00001D58  4EB9 00001F16           1146              JSR         INVALID_INST        ; Instruction  is invalid
00001D5E  4E75                    1147              RTS
00001D60                          1148  GROUP4_1100 
00001D60  4EB9 00001F16           1149              JSR         INVALID_INST        ; Instruction  is invalid
00001D66  4E75                    1150              RTS
00001D68                          1151  GROUP4_1101 
00001D68  4EB9 00001F16           1152              JSR         INVALID_INST        ; Instruction  is invalid
00001D6E  4E75                    1153              RTS
00001D70                          1154  GROUP4_1111 
00001D70  4EB9 00001F16           1155              JSR         INVALID_INST        ; Instruction  is invalid
00001D76  4E75                    1156              RTS   
00001D78                          1157  
00001D78                          1158  
00001D78                          1159  *--------------------------------------------------------------------------------------------------------------
00001D78                          1160  *   OPCODE: 0100 1110 (NOP, RTS, JSR, JMP)
00001D78                          1161  *-------------------------------------------------------------------------------------------------------------- 
00001D78                          1162  
00001D78                          1163  GROUP4_1110 
00001D78  4EB9 00001DF4           1164              JSR         GET_SIZE            ; Gets size for JSR and JMP instructions
00001D7E  BC3C 0002               1165              CMP.B       #%10,D6             ; Is instruction JSR?
00001D82  6700 0028               1166              BEQ         OP_JSR              ; If yes, go to JSR
00001D86  BC3C 0003               1167              CMP.B       #%11,D6             ; Is instruction JMP?
00001D8A  6700 003C               1168              BEQ         OP_JMP              ; If yes, go to JMP
00001D8E  BE7C 4E75               1169              CMP.W       #$4E75,D7           ; Is instruction RTS?
00001D92  6700 0050               1170              BEQ         OP_RTS              ; If yes, go to RTS           
00001D96  BE7C 4E71               1171              CMP.W       #$4E71,D7           ; Is instruction NOP?
00001D9A  6600 017A               1172              BNE         INVALID_INST        ; Instruction  is invalid
00001D9E                          1173               
00001D9E  14FC 004E               1174              MOVE.B      #'N',(A2)+          ; Puts NOP into buffer
00001DA2  14FC 004F               1175              MOVE.B      #'O',(A2)+
00001DA6  14FC 0050               1176              MOVE.B      #'P',(A2)+
00001DAA  4E75                    1177              RTS
00001DAC                          1178                                        
00001DAC  14FC 004A               1179  OP_JSR      MOVE.B      #'J',(A2)+          ; Puts JSR into buffer
00001DB0  14FC 0053               1180              MOVE.B      #'S',(A2)+
00001DB4  14FC 0052               1181              MOVE.B      #'R',(A2)+
00001DB8  14FC 0020               1182              MOVE.B      #' ',(A2)+
00001DBC  14FC 0009               1183              MOVE.B      #$09,(A2)+          ; Adds 5 extra spacings
00001DC0  4EF9 00002074           1184              JMP         GET_EA              ; Insert EA 
00001DC6                          1185  
00001DC6  4E75                    1186              RTS
00001DC8                          1187                         
00001DC8  14FC 004A               1188  OP_JMP      MOVE.B      #'J',(A2)+          ; Puts JMP into buffer
00001DCC  14FC 004D               1189              MOVE.B      #'M',(A2)+
00001DD0  14FC 0050               1190              MOVE.B      #'P',(A2)+
00001DD4  14FC 0020               1191              MOVE.B      #' ',(A2)+
00001DD8  14FC 0009               1192              MOVE.B      #$09,(A2)+          ; Adds 5 extra spacings
00001DDC  4EB9 00002074           1193              JSR         GET_EA              ; Insert EA             
00001DE2  4E75                    1194              RTS
00001DE4                          1195                                   
00001DE4  14FC 0052               1196  OP_RTS      MOVE.B      #'R',(A2)+          ; Puts RTS into buffer
00001DE8  14FC 0054               1197              MOVE.B      #'T',(A2)+
00001DEC  14FC 0053               1198              MOVE.B      #'S',(A2)+             
00001DF0  4E75                    1199              RTS
00001DF2                          1200              
00001DF2                          1201  GROUP2_1111 
00001DF2  4E75                    1202              RTS    
00001DF4                          1203              
00001DF4                          1204  
00001DF4                          1205  *--------------------------------------------------------------------------------------------------------------
00001DF4                          1206  *   OPCODE SIZE METHODS: Checks size of instruction
00001DF4                          1207  *--------------------------------------------------------------------------------------------------------------    
00001DF4                          1208  
00001DF4  3C07                    1209  GET_SIZE    MOVE.W      D7,D6               ; Copies current instruction to shift register
00001DF6  EC4E                    1210              LSR.W       #6,D6               ; Shifts instruction left 6 bits 
00001DF8  0246 0003               1211              ANDI.W      #$0003,D6           ; Removes non-size bits to store result into D6
00001DFC  4E75                    1212              RTS
00001DFE                          1213  
00001DFE  4EB8 1DF4               1214  FIND_SIZE   JSR         GET_SIZE
00001E02  BC3C 0000               1215              CMP.B       #%00,D6             ; Is value a byte?
00001E06  6700 001C               1216              BEQ         IS_B                ; If yes, add B to buffer
00001E0A  BC3C 0001               1217              CMP.B       #%01,D6             ; Is value a word?
00001E0E  6700 001E               1218              BEQ         IS_W                ; If yes, add W to buffer
00001E12  BC3C 0002               1219              CMP.B       #%10,D6             ; Is value a long?
00001E16  6600 00FE               1220              BNE         INVALID_INST        ; If no, instruction invalid
00001E1A                          1221        
00001E1A  14FC 004C               1222              MOVE.B      #'L',(A2)+          ; Adds L to buffer
00001E1E  4EF9 00001E32           1223              JMP         FIND_END            ; End Find  
00001E24                          1224              
00001E24  14FC 0042               1225  IS_B        MOVE.B      #'B',(A2)+          ; Adds B to buffer
00001E28  4EF9 00001E32           1226              JMP         FIND_END            ; End Find
00001E2E                          1227              
00001E2E  14FC 0057               1228  IS_W        MOVE.B      #'W',(A2)+          ; Adds W to buffer
00001E32                          1229  
00001E32  4E75                    1230  FIND_END    RTS     
00001E34                          1231  
00001E34                          1232  
00001E34                          1233  *--------------------------------------------------------------------------------------------------------------
00001E34                          1234  *   OPCODE MOVE/MOVEA METHODS: Swap destination and source regsisters
00001E34                          1235  *--------------------------------------------------------------------------------------------------------------    
00001E34                          1236   
00001E34  4283                    1237  MOVE_SWAP   CLR.L       D3                  ; Clears D3 to hold swap value
00001E36  3C07                    1238              MOVE.W      D7,D6               ; Get copy of instruction to shift
00001E38  E04E                    1239              LSR.W       #08,D6              ; Shifts 8 bits left
00001E3A  E24E                    1240              LSR.W       #1,D6               ; Shifts 1 extra time to total 9
00001E3C  0246 0007               1241              ANDI.W      #$0007,D6           ; Mask last 3 bits
00001E40  8646                    1242              OR.W        D6,D3               ; Place bits in D3 to swap
00001E42  3C07                    1243              MOVE.W      D7,D6               ; Get copy of instruction to shift
00001E44  E64E                    1244              LSR.W       #3,D6               ; Shifts back into normal position
00001E46  0246 0038               1245              ANDI.W      #$0038,D6           ; Mask bits 3-5
00001E4A  8646                    1246              OR.W        D6,D3               ; Place bits in D3
00001E4C  4EB9 00001E56           1247              JSR         MOVE_SIZE           ; Add move size bits 6-7 into D3 for ea
00001E52  3E03                    1248              MOVE.W      D3,D7               ; Swap register mode to determine destination from ea
00001E54  4E75                    1249              RTS
00001E56                          1250              
00001E56                          1251              
00001E56  3C07                    1252  MOVE_SIZE   MOVE.W      D7,D6               ; Get copy of instruction to shift
00001E58  E04E                    1253              LSR.W       #08,D6              ; Shifts 8 bits left
00001E5A  E84E                    1254              LSR.W       #04,D6              ; Shifts 6 bits left
00001E5C  0246 0003               1255              ANDI.W      #$0003,D6           ; Isolate move bits
00001E60  BC3C 0001               1256              CMP.B       #$1,D6              ; Is value a byte?
00001E64  6700 0020               1257              BEQ         SIZE_END            ; If yes, byte size already in bits 6-7 of D3
00001E68  BC3C 0002               1258              CMP.B       #$2,D6              ; Is value a long?
00001E6C  6700 0014               1259              BEQ         SIZE_L              ; If yes, L size to D3 bits 6-7
00001E70  BC3C 0003               1260              CMP.B       #$3,D6              ; Is value a word?
00001E74  6600 00A0               1261              BNE         INVALID_INST        ; If no, instruction invalid
00001E78                          1262          
00001E78  0043 0040               1263  SIZE_W      ORI.W       #$0040,D3           ; Add size 01 in bits 6-7, 4 into D3
00001E7C  4EF9 00001E86           1264              JMP         SIZE_END            ; End Size
00001E82                          1265              
00001E82  0043 0080               1266  SIZE_L      ORI.W       #$0080,D3           ; Add size 10 in bits 6-7, 4 into D3
00001E86                          1267  
00001E86  4E75                    1268  SIZE_END    RTS 
00001E88                          1269                    
00001E88                          1270  *--------------------------------------------------------------------------------------------------------------
00001E88                          1271  *   OPCODE ASd, LSd, ROd METHODS: Finds bit direction and helps insert/print data
00001E88                          1272  *-------------------------------------------------------------------------------------------------------------- 
00001E88                          1273  
00001E88  4EB9 00001EF2           1274  GET_DIR     JSR         DIR_BIT             ; Gets direction bit returned in D6
00001E8E  BC3C 0000               1275              CMP.B       #%0,D6              ; Is this Right?
00001E92  6700 000C               1276              BEQ         IS_dirR             ; If yes, populate right  
00001E96  14FC 004C               1277  IS_dirL     MOVE.B      #'L',(A2)+          ; If no, populate L for left
00001E9A  4EF9 00001EA4           1278              JMP         END_DIR             ; Jump to end
00001EA0  14FC 0052               1279  IS_dirR     MOVE.B      #'R',(A2)+
00001EA4  4E75                    1280  END_DIR     RTS
00001EA6                          1281  
00001EA6                          1282  
00001EA6  3C07                    1283  GET_IR      MOVE.W      D7,D6               ; Get new instruction
00001EA8  EA8E                    1284              LSR.L       #5,D6               ; Shift bit 5 into LSB
00001EAA  0246 0001               1285              ANDI.W      #$0001,D6           ; Get fifth bit
00001EAE  BC3C 0000               1286              CMP.B       #%0,D6              ; Is this the count shift?
00001EB2  6700 000C               1287              BEQ         VAL_SRC             ; If yes, insert value source
00001EB6  14FC 0044               1288              MOVE.B      #'D',(A2)+          ; Adds D for data register
00001EBA  4EF9 00001EC4           1289              JMP         VAL_SIZ             ; Insert value size
00001EC0  14FC 0023               1290  VAL_SRC     MOVE.B      #'#',(A2)+          ; Print value source
00001EC4  4EB9 00001EE0           1291  VAL_SIZ     JSR         HIGH_ADD            ; Add register number to buffer
00001ECA  14FC 002C               1292              MOVE.B      #',',(A2)+          ; Adds comma between data
00001ECE  14FC 0044               1293              MOVE.B      #'D',(A2)+          ; Adds D for data register
00001ED2  3C07                    1294              MOVE.W      D7,D6               ; Get new instruction
00001ED4  0246 0007               1295              ANDI.W      #$0007,D6           ; Get bits 0-2
00001ED8  0606 0030               1296              ADD.B       #$30,D6             ; Convert shift reg to ASCII
00001EDC  14C6                    1297              MOVE.B      D6,(A2)+            ; Add low reigster number to buffer
00001EDE  4E75                    1298  END_IR      RTS
00001EE0                          1299  
00001EE0                          1300  
00001EE0                          1301  *--------------------------------------------------------------------------------------------------------------
00001EE0                          1302  *   OPCODE PRINT DATA: Adds upper register data to buffer
00001EE0                          1303  *--------------------------------------------------------------------------------------------------------------
00001EE0                          1304  
00001EE0  3C07                    1305  HIGH_ADD    MOVE.W      D7,D6               ; Get new instruction
00001EE2  E08E                    1306              LSR.L       #08,D6              ; Shifts 8 bits left
00001EE4  E28E                    1307              LSR.L       #1,D6               ; Shifts 1 extra time to total 9
00001EE6  0206 0007               1308              ANDI.B      #$7,D6              ; Get last 7 bits for register number
00001EEA  0606 0030               1309              ADD.B       #$30,D6             ; Convert register number to ascii
00001EEE  14C6                    1310              MOVE.B      D6,(A2)+            ; Number into buffer
00001EF0  4E75                    1311              RTS
00001EF2                          1312  
00001EF2  3C07                    1313  DIR_BIT     MOVE.W      D7,D6               ; Get new instruction
00001EF4  E08E                    1314              LSR.L       #08,D6              ; Shifts to get eighth bit
00001EF6  0206 0001               1315              ANDI.B      #01,D6              ; Get last bit
00001EFA  4E75                    1316              RTS  
00001EFC                          1317              
00001EFC  BC3C 0000               1318  LOAD_SIZE   CMP.B       #%00,D6             ; Is value a byte?
00001F00  6700 02BC               1319              BEQ         BYTE_BUFFER         ; If yes, insert B amount of address into buffer
00001F04  BC3C 0001               1320              CMP.B       #%01,D6             ; Is value a word?
00001F08  6700 02E2               1321              BEQ         WORD_BUFFER         ; If yes, insert W amount of address into buffer
00001F0C  BC3C 0002               1322              CMP.B       #%10,D6             ; Is value a long?
00001F10  6700 030C               1323              BEQ         LONG_BUFFER         ; If yes, insert L amount of address into buffer
00001F14  4E75                    1324              RTS
00001F16                          1325  
00001F16                          1326  
00001F16                          1327  *--------------------------------------------------------------------------------------------------------------
00001F16                          1328  *   OPCODE INVALID: Puts DATA as placeholder for instruction
00001F16                          1329  *--------------------------------------------------------------------------------------------------------------
00001F16                          1330              
00001F16                          1331  INVALID_INST
00001F16  1A3C 0000               1332              MOVE.B      #FALSE,D5           ; Boolean = FALSE
00001F1A  244B                    1333              MOVEA.L     A3,A2               ; Resets buffer pointer 
00001F1C  14FC 0044               1334              MOVE.B      #'D',(A2)+          ; Add DATA to buffer as placeholder
00001F20  14FC 0041               1335              MOVE.B      #'A',(A2)+
00001F24  14FC 0054               1336              MOVE.B      #'T',(A2)+
00001F28  14FC 0041               1337              MOVE.B      #'A',(A2)+
00001F2C  14FC 0009               1338              MOVE.B      #$09,(A2)+
00001F30  14FC 0024               1339              MOVE.B      #'$',(A2)+          ; ADD $ for address
00001F34  4EB9 00001F3C           1340              JSR         GET_INVALID         ; Insert cooresponding data to buffer
00001F3A  4E75                    1341              RTS          
00001F3C                          1342  
00001F3C                          1343  GET_INVALID
00001F3C  7C00                    1344              MOVEQ       #$0,D6              ; Clear D6 for copying word
00001F3E  3C07                    1345              MOVE.W      D7,D6               ; Copy word instruction to D6
00001F40  183C 000C               1346              MOVE.B      #12,D4              ; Add 12 bytes to be shifted
00001F44  E8AE                    1347              LSR.L       D4,D6               ; Shift D^ 12 bytes left
00001F46  0246 000F               1348              ANDI.W      #$000F,D6           ; Get last 4 bits
00001F4A  4EB9 00001F82           1349              JSR         HEX_TO_ASCII        ; Add first value to buffer
00001F50  3C07                    1350              MOVE.W      D7,D6
00001F52  183C 0008               1351              MOVE.B      #08,D4
00001F56  E8AE                    1352              LSR.L       D4,D6
00001F58  0246 000F               1353              ANDI.W      #$000F,D6
00001F5C  4EB9 00001F82           1354              JSR         HEX_TO_ASCII        ; Add second value to buffer
00001F62  3C07                    1355              MOVE.W      D7,D6
00001F64  183C 0004               1356              MOVE.B      #04,D4
00001F68  E8AE                    1357              LSR.L       D4,D6
00001F6A  0246 000F               1358              ANDI.W      #$000F,D6
00001F6E  4EB9 00001F82           1359              JSR         HEX_TO_ASCII        ; Add third value to buffer
00001F74  3C07                    1360              MOVE.W      D7,D6
00001F76  0246 000F               1361              ANDI.W      #$000F,D6
00001F7A  4EB9 00001F82           1362              JSR         HEX_TO_ASCII        ; Add fourth value to buffer
00001F80  4E75                    1363              RTS
00001F82                          1364            
00001F82                          1365  
00001F82                          1366  *--------------------------------------------------------------------------------------------------------------
00001F82                          1367  *   Hex to ASCII: converts hex to ascii
00001F82                          1368  *--------------------------------------------------------------------------------------------------------------
00001F82                          1369  
00001F82                          1370  HEX_TO_ASCII
00001F82  BC3C 000A               1371              CMP.B       #$A,D6              ; Confirm is value is a hex character
00001F86  6C00 000A               1372              BGE         LETTER              ; Checks if value is a letter or number
00001F8A  0606 0030               1373              ADDI.B      #$30,D6             ; Converts value to ASCII
00001F8E  6000 0006               1374              BRA         TO_BUFFER           ; Save to buffer
00001F92                          1375              
00001F92  0606 0037               1376  LETTER      ADDI.B      #$37,D6             ; Checks if value is a letter or number
00001F96                          1377  
00001F96  14C6                    1378  TO_BUFFER   MOVE.B      D6,(A2)+            ; Save to buffer
00001F98  4E75                    1379              RTS
00001F9A                          1380  
00001F9A                          1381  
00001F9A                          1382  *--------------------------------------------------------------------------------------------------------------
00001F9A                          1383  *   FORMAT ADDRESS OUTPUT: for data to be displayed next to each corresponding address
00001F9A                          1384  *--------------------------------------------------------------------------------------------------------------
00001F9A                          1385  
00001F9A  4EB9 00001FF6           1386  FORMAT_ADD  JSR         SHIFT1              ; Clears D6 to load new value
00001FA0  183C 000C               1387              MOVE.B      #12,D4              ; Assigns D4 with 12 bits to shift
00001FA4  4EB9 00001FFE           1388              JSR         SHIFT2              ; Shifts 12 bits
00001FAA  183C 0008               1389              MOVE.B      #08,D4              ; Assigns D4 with 8 bits to shift
00001FAE  4EB9 00001FFE           1390              JSR         SHIFT2              ; Shifts 8 bits
00001FB4  183C 0004               1391              MOVE.B      #04,D4              ; Assigns D4 with 4 bits to shift
00001FB8  4EB9 00001FFE           1392              JSR         SHIFT2              ; Shifts 4 bits
00001FBE  183C 0000               1393              MOVE.B      #0,D4               ; Clear D4 register
00001FC2  4EB9 00002016           1394              JSR         SHIFT4              ; Shifts no bits
00001FC8                          1395              
00001FC8  183C 000C               1396              MOVE.B      #12,D4              ; Assigns D4 with 12 bits to shift
00001FCC  4EB9 00002016           1397              JSR         SHIFT4              ; Shifts 12 bits
00001FD2  183C 0008               1398              MOVE.B      #08,D4              ; Assigns D4 with 8 bits to shift
00001FD6  4EB9 00002016           1399              JSR         SHIFT4              ; Shifts 8 bits
00001FDC  183C 0004               1400              MOVE.B      #04,D4              ; Assigns D4 with 4 bits to shift
00001FE0  4EB9 00002016           1401              JSR         SHIFT4              ; Shifts 4 bits
00001FE6  183C 0000               1402              MOVE.B      #0,D4               ; Clear D4 register
00001FEA  E8AE                    1403              LSR.L       D4,D6               ; Shifts address left 0 bits
00001FEC                          1404              
00001FEC  0286 0000000F           1405              ANDI.L      #$0000000F,D6       ; Gets last bit of address
00001FF2  4EB8 1F82               1406              JSR         HEX_TO_ASCII        ; Places value in buffer
00001FF6                          1407  
00001FF6  7C00                    1408  SHIFT1      MOVEQ       #$0,D6              ; Clears D6 register
00001FF8  2C08                    1409              MOVE.L      A0,D6               ; Loads current address to print in output
00001FFA  4846                    1410              SWAP        D6                  ; Swaps high and low words
00001FFC  4E75                    1411              RTS
00001FFE                          1412  
00001FFE  E8AE                    1413  SHIFT2      LSR.L       D4,D6               ; Shifts address left x bits
00002000  0286 0000000F           1414              ANDI.L      #$0000000F,D6       ; Gets last bit of address
00002006  4EB8 1F82               1415              JSR         HEX_TO_ASCII        ; Places value in buffer
0000200A  4EB8 1FF6               1416              JSR         SHIFT1              ; Reset address for next shift
0000200E  4E75                    1417              RTS
00002010                          1418  
00002010  7C00                    1419  SHIFT3      MOVEQ       #$0,D6              ; Clears D6 address register
00002012  2C08                    1420              MOVE.L      A0,D6               ; Loads current address to print in output
00002014  4E75                    1421              RTS
00002016                          1422              
00002016  E8AE                    1423  SHIFT4      LSR.L       D4,D6               ; Shifts address left x bits
00002018  0286 0000000F           1424              ANDI.L      #$0000000F,D6       ; Gets last bit of address
0000201E  4EB8 1F82               1425              JSR         HEX_TO_ASCII        ; Place address value into buffer
00002022  4EB8 2010               1426              JSR         SHIFT3              ; Reset address for next shift
00002026  4E75                    1427              RTS
00002028                          1428  
00002028                          1429  
00002028                          1430  *--------------------------------------------------------------------------------------------------------------
00002028                          1431  *   CLEAR METHODS
00002028                          1432  *--------------------------------------------------------------------------------------------------------------    
00002028                          1433        
00002028                          1434  CLEAR_REG1
00002028  4240                    1435              CLR         D0                  ; Clears all data registers
0000202A  4241                    1436              CLR         D1
0000202C  4242                    1437              CLR         D2
0000202E  4243                    1438              CLR         D3
00002030  4244                    1439              CLR         D4
00002032  4245                    1440              CLR         D5
00002034  4246                    1441              CLR         D6
00002036  4247                    1442              CLR         D7            
00002038  207C 00000000           1443              MOVEA.L     #$0, A0             ; Clears all address registers
0000203E  227C 00000000           1444              MOVEA.L     #$0, A1
00002044  247C 00000000           1445              MOVEA.L     #$0, A2
0000204A  267C 00000000           1446              MOVEA.L     #$0, A3
00002050  287C 00000000           1447              MOVEA.L     #$0, A4
00002056  2A7C 00000000           1448              MOVEA.L     #$0, A5
0000205C  2C7C 00000000           1449              MOVEA.L     #$0, A6            
00002062  4E75                    1450              RTS
00002064                          1451               
00002064                          1452  CLEAR_REG2  
00002064  4280                    1453              CLR.L       D0                  ; Clears each register except boolean (D5)
00002066  4281                    1454              CLR.L       D1
00002068  4282                    1455              CLR.L       D2
0000206A  4283                    1456              CLR.L       D3
0000206C  4284                    1457              CLR.L       D4
0000206E  4286                    1458              CLR.L       D6
00002070  4287                    1459              CLR.L       D7
00002072  4E75                    1460              RTS     
00002074                          1461  
00002074                          1462  
00002074                          1463  *-------------------------------------------------------------------------------------------------------------------------------------------------------------------
00002074                          1464  *===============================================================EA_ROUTINES=========================================================================================
00002074                          1465  *-------------------------------------------------------------------------------------------------------------------------------------------------------------------
00002074                          1466  
00002074                          1467  *--------------------------------------------------------------------------------------------------------------
00002074                          1468  *   START OF EA ROUTINE
00002074                          1469  *--------------------------------------------------------------------------------------------------------------            
00002074                          1470  
00002074                          1471  GET_EA       
00002074  4BF9 0000209E           1472              LEA         EA_Modes,A5         ; Load EA_modes into D5
0000207A  4282                    1473              CLR.L       D2                  ; Clear registers
0000207C  4283                    1474              CLR.L       D3
0000207E  4284                    1475              CLR.L       D4           
00002080  4286                    1476              CLR.L       D6
00002082  3C07                    1477              MOVE.W      D7,D6               ; Move word into D6
00002084  0246 003F               1478              ANDI.W      #$003F,D6           ; Leave mode bits
00002088  123C 0003               1479              MOVE.B      #3,D1               ; Load D1 with bits to shift            
0000208C  E26E                    1480              LSR.W       D1,D6               ; Shifts D6 Right with valuein D1            
0000208E                          1481  
0000208E  CCFC 0006               1482              MULU        #6,D6               ; Becomes offset for Index table            
00002092  4EB5 6000               1483              JSR         00(A5,D6)           ; Go back to Index table        
00002096                          1484  
00002096  4E75                    1485              RTS                             ; Return from EA routine
00002098                          1486          
00002098  4EF9 000024CA           1487              JMP         END
0000209E                          1488  
0000209E                          1489  
0000209E                          1490  *--------------------------------------------------------------------------------------------------------------
0000209E                          1491  *   EA TABLE AND MODES
0000209E                          1492  *-------------------------------------------------------------------------------------------------------------- 
0000209E                          1493     
0000209E                          1494  EA_Modes                             
0000209E  4EF9 000020CE           1495              JMP         EA_000              ; Data Register Dn
000020A4  4EF9 000020E0           1496              JMP         EA_001              ; Address Register An
000020AA  4EF9 000020F2           1497              JMP         EA_010              ; Indirect Address Register (An)
000020B0  4EF9 0000210C           1498              JMP         EA_011              ; Indirect w/ Post Increment (An)+
000020B6  4EF9 0000212A           1499              JMP         EA_100              ; Indirect w/ Pre Decrement -(An)
000020BC  4EF9 00002148           1500              JMP         EA_101              ; Indirect Address Register using Index
000020C2  4EF9 0000214C           1501              JMP         EA_110              ; Address Register w/ Index
000020C8  4EF9 00002150           1502              JMP         EA_111              ; Absolute (.W or .L) or Immediate EA
000020CE                          1503  
000020CE                          1504   
000020CE  3C07                    1505  EA_000      MOVE.W      D7,D6               ; Move current word value into temp
000020D0  0246 0007               1506              ANDI.W      #$7,D6              ; Get last 3 register bits
000020D4  14FC 0044               1507              MOVE.B      #$44,(A2)+          ; Adds D for data register to buffer
000020D8  0606 0030               1508              ADD.B       #$30,D6             ; Convert data value to hex
000020DC  14C6                    1509              MOVE.B      D6,(A2)+            ; Add number to buffer                  
000020DE                          1510              
000020DE  4E75                    1511              RTS
000020E0                          1512    
000020E0                          1513  EA_001
000020E0  3C07                    1514              MOVE.W      D7,D6               ; Move current word value into temp
000020E2  0246 0007               1515              ANDI.W      #$7,D6              ; Get last 3 register bits
000020E6  14FC 0041               1516              MOVE.B      #$41,(A2)+          ; Adds A for address register to buffer
000020EA  0606 0030               1517              ADD.B       #$30,D6             ; Convert data value to hex
000020EE  14C6                    1518              MOVE.B      D6,(A2)+            ; Add number to buffer
000020F0                          1519                
000020F0  4E75                    1520              RTS
000020F2                          1521    
000020F2                          1522  EA_010
000020F2  3C07                    1523              MOVE.W      D7,D6               ; Move current word value into temp
000020F4  0246 0007               1524              ANDI.W      #$7,D6              ; Get last 3 register bits
000020F8  14FC 0028               1525              MOVE.B      #$28,(A2)+          ; Adds ( to buffer            
000020FC  14FC 0041               1526              MOVE.B      #$41,(A2)+          ; Adds A for address register to buffer
00002100  0606 0030               1527              ADD.B       #$30,D6             ; Convert data value to hex
00002104  14C6                    1528              MOVE.B      D6,(A2)+            ; Add number to buffer
00002106  14FC 0029               1529              MOVE.B      #$29,(A2)+          ; Adds ) to buffer
0000210A                          1530               
0000210A  4E75                    1531              RTS
0000210C                          1532  
0000210C                          1533  EA_011
0000210C                          1534              
0000210C  3C07                    1535              MOVE.W      D7,D6               ; Move current word value into temp
0000210E  0246 0007               1536              ANDI.W      #$7,D6              ; Get last 3 register bits
00002112  14FC 0028               1537              MOVE.B      #$28,(A2)+          ; Adds ( to buffer              
00002116  14FC 0041               1538              MOVE.B      #$41,(A2)+          ; Adds A for address register to buffer
0000211A  0606 0030               1539              ADD.B       #$30,D6             ; Convert data value to hex
0000211E  14C6                    1540              MOVE.B      D6,(A2)+            ; Add number to buffer
00002120  14FC 0029               1541              MOVE.B      #$29,(A2)+          ; Adds ) to buffer
00002124  14FC 002B               1542              MOVE.B      #$2B,(A2)+          ; Adds + to buffer
00002128                          1543                   
00002128  4E75                    1544              RTS
0000212A                          1545    
0000212A                          1546  EA_100
0000212A                          1547             
0000212A  3C07                    1548              MOVE.W      D7,D6               ; Move current word value into temp
0000212C  0246 0007               1549              ANDI.W      #$7,D6              ; Get last 3 register bits
00002130  14FC 002D               1550              MOVE.B      #$2D,(A2)+          ; Adds - to buffer
00002134  14FC 0028               1551              MOVE.B      #$28,(A2)+          ; Adds ( to buffer            
00002138  14FC 0041               1552              MOVE.B      #$41,(A2)+          ; Adds A for address register to buffer
0000213C  0606 0030               1553              ADD.B       #$30,D6             ; Convert data value to hex
00002140  14C6                    1554              MOVE.B      D6,(A2)+            ; Add number to buffer
00002142  14FC 0029               1555              MOVE.B      #$29,(A2)+          ; Adds ) to buffer
00002146                          1556              
00002146  4E75                    1557              RTS
00002148                          1558  
00002148                          1559  EA_101
00002148  4EF8 1F16               1560              JMP         INVALID_INST        ; Instruction is invalid
0000214C                          1561  
0000214C                          1562  EA_110
0000214C  4EF8 1F16               1563              JMP         INVALID_INST        ; Instruction is invalid
00002150                          1564  
00002150                          1565  EA_111
00002150  4EB9 0000217C           1566              JSR         REG_BITS            ; Get register bits
00002156  0C06 0000               1567              CMPI.B      #$0,D6              ; Is bit a word?
0000215A  6700 0090               1568              BEQ         WORD_BUFFER         ; Insert word address in buffer
0000215E  0C06 0001               1569              CMPI.B      #$1,D6              ; Is bit a long?
00002162  6700 00BA               1570              BEQ         LONG_BUFFER         ; Insert long address in buffer
00002166  0C06 0002               1571              CMPI.B      #$2,D6
0000216A                          1572  
0000216A  0C06 0002               1573              CMPI.B      #$2,D6              ; Is it PC w/ Displacement?
0000216E  6700 0036               1574              BEQ         PRINT_PC            ; If yes, print PC
00002172  0C06 0004               1575              CMPI.B      #$4,D6              ; Is it Immediate?
00002176  6700 000C               1576              BEQ         IM_BUFFER           ; If yes, go to immediate buffer
0000217A                          1577             
0000217A  4E75                    1578              RTS
0000217C                          1579  
0000217C                          1580  
0000217C                          1581  *--------------------------------------------------------------------------------------------------------------
0000217C                          1582  *   EA SUBROUTINES
0000217C                          1583  *--------------------------------------------------------------------------------------------------------------
0000217C                          1584  
0000217C  3C07                    1585  REG_BITS    MOVE.W      D7,D6               ; Value in D2 becomes what is in A0
0000217E  0246 0007               1586              ANDI.W      #$07,D6
00002182  4E75                    1587              RTS
00002184                          1588              
00002184                          1589  IM_BUFFER 
00002184  14FC 0023               1590              MOVE.B      #'#',(A2)+
00002188  4EB8 1E56               1591              JSR         MOVE_SIZE
0000218C  0C06 0001               1592              CMPI.B      #$1,D6              ; Is value a word?
00002190  6700 002C               1593              BEQ         BYTE_BUFFER         ; If yes, put word address in buffer
00002194  0C06 0003               1594              CMPI.B      #$3,D6              ; Is value a long?
00002198  6700 0052               1595              BEQ         WORD_BUFFER         ; If yes, put word address in buffer            
0000219C  0C06 0002               1596              CMPI.B      #$2,D6
000021A0  6700 007C               1597              BEQ         LONG_BUFFER
000021A4  4E75                    1598              RTS
000021A6                          1599              
000021A6                          1600  PRINT_PC
000021A6  4EB9 000021EC           1601              JSR         WORD_BUFFER
000021AC  14FC 0028               1602              MOVE.B      #$28,(A2)+          ; Adds ( to buffer            
000021B0  14FC 0050               1603              MOVE.B      #$50,(A2)+          ; Adds P to buffer
000021B4  14FC 0043               1604              MOVE.B      #$43,(A2)+          ; Adds C to buffer
000021B8  14FC 0029               1605              MOVE.B      #$29,(A2)+          ; Adds ) to buffer                        
000021BC  4E75                    1606              RTS
000021BE                          1607  
000021BE                          1608  
000021BE                          1609  *--------------------------------------------------------------------------------------------------------------
000021BE                          1610  *   BYTE_BUFFER
000021BE                          1611  *--------------------------------------------------------------------------------------------------------------
000021BE                          1612              
000021BE                          1613  BYTE_BUFFER   
000021BE  14FC 0024               1614              MOVE.B      #'$',(A2)+          ; To add $ before address
000021C2  4284                    1615              CLR.L       D4                  ; Clear D4
000021C4  3410                    1616              MOVE.W      (A0),D2             ; Move current value into D2
000021C6  4284                    1617              CLR.L       D4                  ; Clear D4
000021C8  183C 0002               1618              MOVE.B      #2,D4               ; Start counter in D4
000021CC                          1619  
000021CC                          1620  b2bLOOP                 
000021CC  B83C 0000               1621              CMP.B       #$00,D4             ; Compares counter with 0
000021D0  6700 0014               1622              BEQ         RETURN_EA0          ; If counter = 0, return
000021D4  E91A                    1623              ROL.B       #4,D2               ; roll the bits in D2 to the left
000021D6  3C02                    1624              MOVE.W      D2,D6               ; Rolled bits go into temp
000021D8  0246 000F               1625              ANDI.W      #$000F,D6           ; Get the ascii value   
000021DC  4EB8 1F82               1626              JSR         HEX_TO_ASCII        ; Insert ascii value into buffer            
000021E0  5304                    1627              SUBQ.B      #$1,D4              ; Subtract from counter
000021E2  4EF8 21CC               1628              JMP         b2bLoop             ; Continue looping until counter = 0
000021E6                          1629              
000021E6  3C07                    1630  RETURN_EA0  MOVE.W      D7,D6               ; Load current word for temp            
000021E8  5448                    1631              ADDQ.W      #2,A0               ; Move memory pointer by word   
000021EA  4E75                    1632              RTS
000021EC                          1633              
000021EC                          1634              
000021EC                          1635  *--------------------------------------------------------------------------------------------------------------
000021EC                          1636  *   WORD_BUFFER
000021EC                          1637  *--------------------------------------------------------------------------------------------------------------
000021EC                          1638  
000021EC                          1639  WORD_BUFFER 
000021EC  14FC 0024               1640              MOVE.B      #'$',(A2)+          ; To add $ before address
000021F0  4284                    1641              CLR.L       D4                  ; Clear D4
000021F2  14FC 0024               1642              MOVE.B      #$24,(A2)+          ; Put $ before address in buffer
000021F6  3410                    1643              MOVE.W      (A0),D2             ; Move current value into D2
000021F8  4284                    1644              CLR.L       D4                  ; Clear D4
000021FA  183C 0004               1645              MOVE.B      #4,D4               ; Start counter in D4
000021FE                          1646  
000021FE                          1647  w2bLOOP                 
000021FE  B83C 0000               1648              CMP.B       #$00,D4             ; Compares counter with 0
00002202  6700 0014               1649              BEQ         RETURN_EA1          ; If counter = 0, return
00002206  E95A                    1650              ROL.W       #4,D2               ; roll the bits in D2 to the left
00002208  3C02                    1651              MOVE.W      D2,D6               ; Rolled bits go into temp
0000220A  0246 000F               1652              ANDI.W      #$000F,D6           ; Get the ascii value      
0000220E  4EB8 1F82               1653              JSR         HEX_TO_ASCII        ; Insert ascii value into buffer           
00002212  5304                    1654              SUBQ.B      #$1,D4              ; Subtract from counter
00002214  4EF8 21FE               1655              JMP         w2bLoop             ; Continue looping until counter = 0
00002218                          1656              
00002218                          1657  RETURN_EA1  
00002218  3C07                    1658              MOVE.W      D7,D6               ; Load current word for temp            
0000221A  5448                    1659              ADDQ.W      #2,A0               ; Move memory pointer by word    
0000221C  4E75                    1660              RTS
0000221E                          1661  
0000221E                          1662  
0000221E                          1663  *--------------------------------------------------------------------------------------------------------------
0000221E                          1664  *   LONG_BUFFER
0000221E                          1665  *--------------------------------------------------------------------------------------------------------------
0000221E                          1666  
0000221E                          1667  LONG_BUFFER
0000221E  14FC 0024               1668              MOVE.B      #'$',(A2)+          ; To add $ before address
00002222  4284                    1669              CLR.L       D4                  ; Clear D4
00002224  2410                    1670              MOVE.L      (A0),D2             ; Move current value into D2
00002226  4284                    1671              CLR.L       D4                  ; Clear D4
00002228  183C 0008               1672              MOVE.B      #8,D4               ; Start counter in D4
0000222C                          1673  
0000222C                          1674  l2bLOOP                 
0000222C  B83C 0000               1675              CMP.B       #$00,D4             ; Compares counter with 0
00002230  6700 0014               1676              BEQ         RETURN_EA2          ; If counter = 0, return
00002234  E99A                    1677              ROL.L       #4,D2               ; roll the bits in D2 to the left
00002236  3C02                    1678              MOVE.W      D2,D6               ; Rolled bits go into temp
00002238  0246 000F               1679              ANDI.W      #$000F,D6           ; Get the ascii value      
0000223C  4EB8 1F82               1680              JSR         HEX_TO_ASCII        ; Insert ascii value into buffer             
00002240  5304                    1681              SUBQ.B      #$1,D4              ; Subtract from counter
00002242  4EF8 222C               1682              JMP         l2bLoop             ; Continue looping until counter = 0
00002246                          1683              
00002246  3C07                    1684  RETURN_EA2  MOVE.W      D7,D6               ; Load current word for temp 
00002248  5848                    1685              ADDQ.W      #4,A0               ; Move memory pointer by word
0000224A  4E75                    1686              RTS
0000224C                          1687  
0000224C                          1688  
0000224C                          1689  *--------------------------------------------------------------------------------------------------------------
0000224C                          1690  *   MESSAGES   
0000224C                          1691  *--------------------------------------------------------------------------------------------------------------
0000224C                          1692              
0000224C= 2D 2D 2D 2D 2D 2D ...   1693  INTRO       DC.B        '------------------------------------------',CR,LF
00002278= 0D 0A 20 20 20 20 ...   1694              DC.B        CR,LF,'           Program Disassembler',CR,LF,CR,LF
0000229D= 2D 2D 2D 2D 2D 2D ...   1695              DC.B        '------------------------------------------',CR,LF,CR,LF
000022CB= 50 6C 65 61 73 65 ...   1696              DC.B        'Please enter a hexidecimal value using characters',CR,LF
000022FE= 5B 30 2D 39 5D 20 ...   1697              DC.B        '[0-9] and [A-F], uppercase letters only.',CR,LF
00002328= 54 68 65 20 73 74 ...   1698              DC.B        'The starting address must be greater than $1000',CR,LF
00002359= 61 6E 64 20 74 68 ...   1699              DC.B        'and the ending address should be greater than',CR,LF
00002388= 74 68 65 20 73 74 ...   1700              DC.B        'the starting address:',CR,LF,0
000023A0                          1701          
000023A0= 45 6E 74 65 72 20 ...   1702  INPUT1      DC.B        'Enter starting address: $',0        ; Ask user for lower boundary
000023BA= 001A                    1703  INPUT1_len  DC.W        INPUT1_len-INPUT1                    ; Gets the length of input string
000023BC                          1704  
000023BC= 45 6E 74 65 72 20 ...   1705  INPUT2      DC.B        'Enter ending address: $',0          ; Ask user for higher boundary
000023D4= 0018                    1706  INPUT2_len  DC.W        INPUT2_len-INPUT2                    ; Gets the length of input string
000023D6                          1707  
000023D6= 45 72 72 6F 72 3A ...   1708  ERRPARAM    DC.B        'Error: input parameters are invalid.',0
000023FC= 0026                    1709  PARAM_len   DC.W        PARAM_len-ERRPARAM
000023FE                          1710  
000023FE= 45 72 72 6F 72 3A ...   1711  ERRSTART    DC.B        'Error: starting hexadecimal address invalid.',0
0000242C= FFD2                    1712  START_len   DC.W        ERRSTART-START_len
0000242E                          1713  
0000242E= 45 72 72 6F 72 3A ...   1714  ERREND      DC.B        'Error: ending hexadecimal address invalid.',0
0000245A= FFD4                    1715  END_len     DC.W        ERREND-END_len
0000245C                          1716  
0000245C= 50 72 65 73 73 20 ...   1717  MORE_DATA   DC.B        'Press enter for more data',0
00002476= FFE6                    1718  MORE_len    DC.W        MORE_DATA-MORE_len
00002478                          1719  
00002478= 57 6F 75 6C 64 20 ...   1720  REPEAT      DC.B        'Would you like to continue disassembling? (Y = 1, N = 0): ',0
000024B4= 003C                    1721  REPEAT_len  DC.W        REPEAT_len-REPEAT      
000024B6                          1722  
000024B6= 456E 6420 6F66 2...     1723  EXIT        DC.W        'End of program',0
000024C6= 0010                    1724  EXIT_len    DC.W        EXIT_len-EXIT           
000024C8                          1725  
000024C8= 01                      1726  main_buff   DC.B        1
000024C9                          1727  
000024C9                          1728  
000024C9                          1729  *--------------------------------------------------------------------------------------------------------------
000024C9                          1730  *   VARIABLES & CONSTANTS
000024C9                          1731  *--------------------------------------------------------------------------------------------------------------
000024C9                          1732  
000024C9  =0000000D               1733  CR          EQU         $0D
000024C9  =0000000A               1734  LF          EQU         $0A
000024C9                          1735  
000024C9  =00000000               1736  minBOUND    EQU         $00000000           ; Minimum bound
000024C9  =00FFFFFF               1737  maxBOUND    EQU         $00FFFFFF           ; Maximum bound
000024C9  =0000A000               1738  stack       EQU         $A000               ; Stack Address
000024C9  =00004000               1739  data        EQU         $4000               ; Data Address
000024C9  =00000019               1740  lineCount   EQU         25                  ; Total lines to be displayed
000024C9  =00000000               1741  length      EQU         0                   ; Effective address length to be stored in D reg
000024C9  =00000001               1742  TRUE        EQU         1                   ; Boolean - is true
000024C9  =00000000               1743  FALSE       EQU         0                   ; Boolean - is false
000024C9                          1744  
000024C9                          1745                                   
000024C9                          1746  *--------------------------------------------------------------------------------------------------------------
000024C9                          1747  *   END OF PROGRAM
000024C9                          1748  *--------------------------------------------------------------------------------------------------------------
000024C9                          1749  
000024CA  4E72 2700               1750  END         STOP        #$2700
000024CE                          1751              END         start

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD1                10C6
ADD2                10DA
ADDAL               19F0
ASCII_TO_HEX        112C
B2BLOOP             21CC
BUFFER              11C2
BYTE_BUFFER         21BE
CHECK_ADDRESS       10BA
CHECK_END           112A
CHECK_ERROR         1114
CHECK_START         10BA
CLEAR_REG1          2028
CLEAR_REG2          2064
CMPAL               1786
CONVERT_TO_HEX      113E
CR                  D
DATA                4000
DECODE_OP           1226
DIR_BIT             1EF2
EA_000              20CE
EA_001              20E0
EA_010              20F2
EA_011              210C
EA_100              212A
EA_101              2148
EA_110              214C
EA_111              2150
EA_MODES            209E
END                 24CA
END0000             1482
END0001             14BE
END0010             1524
END0011             158A
END0100             15EE
END1000             1682
END1001             1740
END1011             183A
END1100             19B2
END1101             1A70
END1110             1BEE
END_BUFFER          1210
END_DIR             1EA4
END_IR              1EDE
END_LEN             245A
EQU1                10EE
EQU2                10FE
EQU3                110E
ERREND              242E
ERRPARAM            23D6
ERRSTART            23FE
EXIT                24B6
EXIT_LEN            24C6
EXIT_PROGRAM        1212
FALSE               0
FIND_END            1E32
FIND_SIZE           1DFE
FORMAT_ADD          1F9A
GET_CAPITAL         119A
GET_DIR             1E88
GET_EA              2074
GET_INPUT           101E
GET_INVALID         1F3C
GET_IR              1EA6
GET_LOWERCASE       11A4
GET_NUMBER          1190
GET_OP              124E
GET_SIZE            1DF4
GROUP1_0000         12C6
GROUP1_0001         1484
GROUP1_0010         14C0
GROUP1_0011         1526
GROUP1_0100         158C
GROUP1_0101         15F0
GROUP1_0110         15F8
GROUP1_0111         1602
GROUP1_1000         160A
GROUP1_1001         1684
GROUP1_1010         1742
GROUP1_1011         174A
GROUP1_1100         183C
GROUP1_1101         19B4
GROUP1_1110         1A72
GROUP1_1111         1BF0
GROUP2_1111         1DF2
GROUP4_0000         1C58
GROUP4_0001         1C60
GROUP4_0010         1C68
GROUP4_0011         1C96
GROUP4_0100         1C9E
GROUP4_0101         1CCC
GROUP4_0110         1CD4
GROUP4_0111         1D02
GROUP4_1000         1D0A
GROUP4_1001         1D48
GROUP4_1010         1D50
GROUP4_1011         1D58
GROUP4_1100         1D60
GROUP4_1101         1D68
GROUP4_1110         1D78
GROUP4_1111         1D70
HEX_TO_ASCII        1F82
HIGH_ADD            1EE0
IM_BUFFER           2184
INPUT1              23A0
INPUT1_LEN          23BA
INPUT2              23BC
INPUT2_LEN          23D4
INTRO               224C
INTRODUCTION        1000
INVALID_HEX         11AE
INVALID_INST        1F16
INVALID_OP          123E
IS_B                1E24
IS_DIRL             1E96
IS_DIRR             1EA0
IS_W                1E2E
L2BLOOP             222C
LENGTH              0
LETTER              1F92
LF                  A
LINECOUNT           19
LOAD_SIZE           1EFC
LONG_BUFFER         221E
MAIN_BUFF           24C8
MAIN_START          100C
MAXBOUND            FFFFFF
MINBOUND            0
MORE_DATA           245C
MORE_LEN            2476
MOVEL               14FA
MOVEL_EA            150E
MOVEW               1560
MOVEWEA             1574
MOVE_PTR            1868
MOVE_SIZE           1E56
MOVE_SWAP           1E34
MULU_MODE           1852
NEXT_STEP           1178
OP_ADD              1A1A
OP_ADD01            1A5C
OP_ADDA             19F4
OP_ADDI             1402
OP_AND              1890
OP_AND01            18DE
OP_ANDEXG           1870
OP_ANDI             1382
OP_ASD              1AD4
OP_ASM              1B90
OP_CMP              17C0
OP_CMPA             178A
OP_CMPEOR           17B0
OP_CMPI             1302
OP_EOR              1800
OP_EORI             1442
OP_EXGA2A           1936
OP_EXGD2A           1974
OP_EXGD2D           18F8
OP_JMP              1DC8
OP_JSR              1DAC
OP_LEA              15BA
OP_LSD              1B08
OP_LSM              1BC2
OP_MOVEM            1D40
OP_MULU             183E
OP_OR               1620
OP_OR01             166E
OP_ORI              1342
OP_ROD              1AA0
OP_ROM              1B5E
OP_RTS              1DE4
OP_SHIFT            1A80
OP_SHMEM            1B3C
OP_SUB              16EA
OP_SUB01            172C
OP_SUBA             16C4
OP_SUBI             13C2
OP_TABLE            1266
OP_TABLE4           1BF8
PARAM_LEN           23FC
PRINT_PC            21A6
REG_BITS            217C
REPEAT              2478
REPEAT_LEN          24B4
RETURN              11B8
RETURN_EA0          21E6
RETURN_EA1          2218
RETURN_EA2          2246
RETURN_OP           1248
SHIFT1              1FF6
SHIFT2              1FFE
SHIFT3              2010
SHIFT4              2016
SIZE_END            1E86
SIZE_L              1E82
SIZE_W              1E78
STACK               A000
START               1000
START_LEN           242C
SUB1                10D6
SUB2                10EA
SUBAL               16C0
TO_BUFFER           1F96
TRUE                1
VAL_SIZ             1EC4
VAL_SRC             1EC0
W2BLOOP             21FE
WORD_BUFFER         21EC
