00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 12/1/2021 5:21:45 PM

00000000                             1  *--------------------------------------------------------------------------------------------------------------
00000000                             2  * Title      : CSS422_DISASSEMBLER
00000000                             3  * Written by : Data Pirates
00000000                             4  * Date       : Autumn 2021
00000000                             5  * Description: Scans a section of memory and attempts to
00000000                             6  *              convert the memoryâ€™s contents to a listing 
00000000                             7  *              of valid assembly language instructions
00000000                             8  *--------------------------------------------------------------------------------------------------------------
00000000                             9  
00000000                            10  
00001000                            11  START       ORG        $1000            ; Start program at $1000
00001000                            12  
00001000                            13  *--------------------------------------------------------------------------------------------------------------
00001000                            14  *   Start Program
00001000                            15  *--------------------------------------------------------------------------------------------------------------
00001000                            16  
00001000                            17  INTRODUCTION
00001000  43F9 0000121A             18              LEA         INTRO,A1        ; Program starting message
00001006  103C 000E                 19              MOVE.B      #14,D0
0000100A  4E4F                      20              TRAP        #15    
0000100C                            21              
0000100C                            22  MAIN_START  
0000100C  6100 00C0                 23              BSR         CLEAR_REG       ; Clear all data registers    
00001010  4FF9 0000A000             24              LEA         stack,SP        ; Load stack pointer  
00001016  45F9 00001380             25              LEA         main_buff,A2    ; Load buffer in A2
0000101C  2C4A                      26              MOVEA.L     A2,A6           ; Reference start of main buffer
0000101E                            27  
0000101E                            28  *--------------------------------------------------------------------------------------------------------------
0000101E                            29  *   USER INPUT   
0000101E                            30  *--------------------------------------------------------------------------------------------------------------
0000101E                            31  
0000101E                            32  GET_INPUT    
0000101E  303C 0001                 33              MOVE        #task1,D0
00001022  43F9 00001298             34              LEA         INPUT1,A1       ; Prompt user to enter start boundary
00001028  3239 000012B2             35              MOVE.W      INPUT1_len,D1         
0000102E  4E4F                      36              TRAP        #15
00001030  D2FC 12B2                 37              ADDA        #INPUT1_len,A1  ; Adds user input after prompt
Line 38 ERROR: Undefined symbol
00001034  303C BD16                 38              MOVE        #task2,D0      
00001038  4E4F                      39              TRAP        #15
Line 40 ERROR: Undefined symbol
0000103A  4EB9 004DBD16             40              JSR         asciiTOhex      ; Save info to stack, checks if valid
00001040  BA3C 0000                 41              CMP.B       #$00,D5         ; Check if boolean is false
00001044                            42              
00001044  2848                      43              MOVEA.L     A0,A4         
00001046  103C 0001                 44              MOVE.B      #task1,D0
0000104A  43F9 000012B4             45              LEA         INPUT2,A1       ; Prompt user to enter end boundary
00001050  3239 000012CC             46              MOVE.W      INPUT2_len,D1         
00001056  4E4F                      47              TRAP        #15         
00001058  D3FC 000012CC             48              ADDA.L      #INPUT2_len,A1  ; Add user input after prompt
Line 49 ERROR: Undefined symbol
0000105E  103C 0016                 49              MOVE.B      #task2,D0
00001062  4E4F                      50              TRAP        #15
Line 51 ERROR: Undefined symbol
00001064  4EB9 004DBD16             51              JSR         asciiTOhex      ; Save info to stack, checks if valid
0000106A  BA3C 0000                 52              CMP.B       #$00,D5         ; Check if boolean is false
0000106E                            53              
0000106E  264C                      54              MOVEA.L     A4,A3           ; Stores starting address into A3
00001070  2848                      55              MOVEA.L     A0,A4           ; Stores endinging address into A4
00001072  204B                      56              MOVEA.L     A3,A0           ; Stores starting address into A0 to be first 
00001074                            57              
00001074  6100 0092                 58              BSR         CHECK_ADDRESS   ; Check if address is valid           
00001078  BA7C 0000                 59              CMP         #FALSE,D5       ; If not valid, Bool = False
0000107C  67A0                      60              BEQ         GET_INPUT       ; Return to input prompts
0000107E                            61              
0000107E  6100 0198                 62              BSR         BUFFER          ; To fill buffer with current address
00001082                            63              
00001082  103C 0001                 64              MOVE.B      #task1,D0
Line 65 ERROR: Undefined symbol
00001086  43F9 004DBD16             65              LEA         REPEAT,A1       ; Asks if user wants to enter new boundaries
Line 66 ERROR: Undefined symbol
0000108C  3239 004DBD16             66              MOVE.W      REPEAT_len,D1
00001092  4E4F                      67              TRAP        #15            
Line 68 ERROR: Undefined symbol
00001094  103C 0016                 68              MOVE.B      #task2,D0
00001098  4E4F                      69              TRAP        #15
0000109A                            70              
0000109A  1611                      71              MOVE.B      (A1),D3         ; Copies user input to D3
0000109C                            72              
0000109C  12FC 0057                 73              MOVE.B      #$57,(A1)+      ; Write in "W"
000010A0  12BC 006F                 74              MOVE.B      #$6F,(A1)       ; Write in "u"
000010A4                            75              
000010A4  B63C 0031                 76              CMP.B       #$31,D3         ; Compares ASCII values to D3
000010A8  6700 FF62                 77              BEQ         MAIN_START
000010AC                            78               
000010AC  6700 FF5E                 79              BEQ         MAIN_START      ; Restart input prompts
000010B0                            80              
000010B0  6100 0008                 81              BSR         EXIT_PROGRAM    ; Exit program                  
Line 82 ERROR: Undefined symbol
000010B4  4EF9 004DBD16             82              JMP         END
000010BA                            83  
000010BA                            84  *--------------------------------------------------------------------------------------------------------------
000010BA                            85  *   Exit and Clear Methods
000010BA                            86  *--------------------------------------------------------------------------------------------------------------
000010BA                            87              
000010BA                            88  EXIT_PROGRAM            
000010BA  103C 0001                 89              MOVE.B      #task1,D0
000010BE  43F9 0000136E             90              LEA         EXIT,A1
000010C4  3239 0000137E             91              MOVE.W      EXIT_len,D1
000010CA  4E4F                      92              TRAP        #15
000010CC  4E75                      93              RTS  
000010CE                            94              
000010CE                            95  CLEAR_REG
000010CE  4240                      96              CLR D0                      ; clears all data registers
000010D0  4241                      97              CLR D1
000010D2  4242                      98              CLR D2                       
000010D4  4243                      99              CLR D3
000010D6  4244                     100              CLR D4
000010D8  4246                     101              CLR D6
000010DA  4247                     102              CLR D7
000010DC                           103              
000010DC  207C 00000000            104              MOVEA.L #$0, A0
000010E2  227C 00000000            105              MOVEA.L #$0, A1
000010E8  247C 00000000            106              MOVEA.L #$0, A2
000010EE  267C 00000000            107              MOVEA.L #$0, A3
000010F4  287C 00000000            108              MOVEA.L #$0, A4
000010FA  2A7C 00000000            109              MOVEA.L #$0, A5
00001100  2C7C 00000000            110              MOVEA.L #$0, A6
00001106  4E75                     111              RTS
00001108                           112  
00001108                           113  *--------------------------------------------------------------------------------------------------------------
00001108                           114  *   CHECK ADDRESS VALIDITY
00001108                           115  *--------------------------------------------------------------------------------------------------------------
00001108                           116  
00001108                           117  CHECK_ADDRESS:
00001108                           118  
00001108                           119  CHECK_START
00001108  BA3C 0000                120              CMP.B       #$00,D5         ; Check if boolean is false
0000110C  6700 0054                121              BEQ         CHECK_ERROR     ; Address error
00001110  1A3C 0001                122              MOVE.B      #TRUE,D5        ; Set boolean to true
00001114                           123  
00001114  2408                     124  ADD1        MOVE.L      A0,D2           ; Loads start boundary to D regs
00001116  2602                     125              MOVE.L      D2,D3
00001118  0203 0001                126              ANDI.B      #1,D3           ; Checks last bit in D2
0000111C  B63C 0001                127              CMP.B       #1,D3
00001120  6600 0260                128              BNE         minBOUND        ; Last bit = 0; go to even branch
00001124                           129              
00001124  5302                     130  SUB1        SUBI.B      #$1,D2          ; Allows odd address to be even
00001126  2042                     131              MOVE.L      D2,A0    
00001128                           132              
00001128  240C                     133  ADD2        MOVE.L      A4,D2           ; Loads ending boundary to D regs
0000112A  2602                     134              MOVE.L      D2,D3
0000112C  0203 0001                135              ANDI.B      #1,D3           ; Checks last bit in D2
00001130  B63C 0001                136              CMP.B       #1,D3
00001134  6600 0006                137              BNE         EQU1 
00001138                           138              
00001138  5302                     139  SUB2        SUBI.B      #$1,D2          ; Allows odd address to be even
0000113A  2842                     140              MOVE.L      D2,A4
0000113C                           141                
0000113C  B1FC 00001384            142  EQU1        CMP.L       #maxBOUND,A0      ; Checks if starting address < $00FFFFFF
00001142  6D00 0008                143              BLT         EQU2            ; If so, branch to EQU2        
00001146  4EF9 00001162            144              JMP         CHECK_ERROR     ; If not, address error
0000114C                           145              
0000114C  B9FC 00001384            146  EQU2        CMP.L       #maxBOUND,A4      ; checks if ending address <= $00FFFFFF
00001152  6F00 0008                147              BLE         EQU3            ; If so, branch to EQU3
00001156  4EF9 00001162            148              JMP         CHECK_ERROR     ; If not, address error               
0000115C                           149              
0000115C  B9C8                     150  EQU3        CMPA.L      A0,A4           ; Checks if ending address > starting address
0000115E  6E00 0018                151              BGT         CHECK_END
00001162                           152                 
00001162                           153  CHECK_ERROR
00001162  103C 0000                154              MOVE.B      #task0,D0
Line 155 ERROR: Undefined symbol
00001166  43F9 004DBD16            155              LEA         ERRPARAM,A1
Line 156 ERROR: Undefined symbol
0000116C  3239 004DBD16            156              MOVE.W      PARAM_len,D1
00001172  4E4F                     157              TRAP        #15        
00001174  1A3C 0000                158              MOVE.B      #FALSE,D5
00001178                           159                          
00001178  4E75                     160  CHECK_END   RTS
0000117A                           161  
0000117A                           162  
0000117A                           163  *--------------------------------------------------------------------------------------------------------------
0000117A                           164  *   Ascii To Hex   
0000117A                           165  *--------------------------------------------------------------------------------------------------------------
0000117A                           166  
0000117A                           167  ASCII_TO_HEX
0000117A                           168  
0000117A  48E7 F800                169              MOVEM.L     D0-D4,-(SP)     ; saves data registers to stack
0000117E  1A3C 0001                170              MOVE.B      #TRUE,D5        ; bool = true 
00001182  4EB8 10CE                171              JSR         CLEAR_REG
00001186  3C3C 0000                172              MOVE        #length,D6 
0000118A                           173              
0000118A                           174  CONVERT_TO_HEX
0000118A                           175              *JSR        CLEAR_REG       ; clears the data registers before starting
0000118A  1419                     176              MOVE.B      (A1)+, D2       ; post increment address reg and move each byte to D2
0000118C  0C02 0030                177              CMPI.B      #$30, D2        ; if equal to 30 and greater its valid 
00001190  6D00 002A                178              BLT         INVALID_HEX     ; if less than 30, that is error in hex number, branches if less than
00001194  0C02 0039                179              CMPI.B      #$39, D2        ; greater than or equal to 30 and less than or equal to 39 would be numbers (0- 9) 
00001198  6F00 003E                180              BLE         GET_NUMBER      ; branches to get number if less than or equal to 39
0000119C  0C02 0040                181              CMPI.B      #$40, D2        ; less than or equal to 40 would be the error inp
000011A0  6F00 001A                182              BLE         INVALID_HEX     
000011A4  0C02 0046                183              CMPI.B      #$46, D2        ; converts to capital 
000011A8  6F00 0038                184              BLE         GET_CAP
000011AC  0C02 0066                185              CMPI.B      #$66, D2        ; converts lowercase letters
000011B0  6F00 003A                186              BLE         GET_LOWERCASE
000011B4  0C02 0066                187              CMPI.B      #$66, D2        
000011B8  6E00 0002                188              BGT         INVALID_HEX     ; if greater than 66, input error
000011BC                           189                            
000011BC                           190  
000011BC                           191              
000011BC                           192  INVALID_HEX 
000011BC                           193              *NEED TO BARNCH TO  RESTART THE PROGRAM/ ASK USER TO ENTER NEW VALUE
000011BC  43F9 000012CE            194              LEA         ERRMSG, A1
000011C2  103C 000E                195              MOVE.B      #14,D0
000011C6  4E4F                     196              TRAP        #15
000011C8                           197              
000011C8  2239 00001386            198              MOVE.L      CURRENTADDR, D1
000011CE  103C 0003                199              MOVE.B      #3, D0      *Prints in decimal
000011D2  4E4F                     200              TRAP        #15
000011D4                           201              
000011D4  6000 FE48                202              BRA         GET_INPUT    *goes back to get the input 
000011D8                           203              
000011D8                           204              
000011D8                           205  GET_NUMBER
000011D8  0402 0030                206              SUBI.B      #$30, D2    *converts val of d2 to hex number val
000011DC  D802                     207              ADD.B       D2, D4      * updates d4 with the latest hex
000011DE  6000 0016                208              BRA         NEXT_STEP   *goes to loop
000011E2                           209              
000011E2                           210  GET_CAP
000011E2  0402 0037                211              SUBI.B      #$37,D2     *converts to capital hex letter
000011E6  D802                     212              ADD.B       D2, D4      * updates the d4 with latest hex
000011E8  6000 000C                213              BRA         NEXT_STEP
000011EC                           214              
000011EC                           215              
000011EC                           216  GET_LOWERCASE
000011EC                           217  
000011EC  0402 0057                218              SUBI.B      #$57, D2    *converts lowercase
000011F0  D802                     219              ADD.B       D2, D4      * updates d4
000011F2  6000 0002                220              BRA         NEXT_STEP
000011F6                           221              
000011F6                           222  NEXT_STEP
000011F6  0C41 0000                223              CMPI.W  #0, D1          *if  the length of input in d1 is 0, then done
Line 224 ERROR: Undefined symbol
000011FA  6700 AB1A                224              BEQ     DONE
000011FE  0C11 0000                225              CMPI.B  #$0, (A1)       *in case its null, done
Line 226 ERROR: Undefined symbol
00001202  6700 AB12                226              BEQ     DONE
00001206                           227              *LSR    #4, D4          *shifts 4 bits to the right for new val
00001206  E94C                     228              LSL     #4, D4          *SHIFTS 4 BITS TO THE LEFT
00001208  5341                     229              SUBI.W  #1, D1          *cuts off the input length
0000120A  6000 FF7E                230              BRA     CONVERT_TO_HEX  * goes back to converting to hex for new val
0000120E                           231              
0000120E                           232              
0000120E                           233                     
0000120E                           234  
0000120E                           235  RETURN    
0000120E  207C 00000000            236              MOVE.L  #0, A0          *basucally empties
00001214  2044                     237              MOVE.L  D4, A0          *moves the final address to a0
00001216  4E75                     238              RTS                     *goes back to subroutine    
00001218                           239  
00001218                           240  *--------------------------------------------------------------------------------------------------------------
00001218                           241  *   BUFFER 
00001218                           242  *--------------------------------------------------------------------------------------------------------------
00001218                           243  
00001218                           244  BUFFER      
00001218                           245              
00001218  4E75                     246  endBuff     RTS   
0000121A                           247  
0000121A                           248  
0000121A                           249  *--------------------------------------------------------------------------------------------------------------
0000121A                           250  *   MESSAGES   
0000121A                           251  *--------------------------------------------------------------------------------------------------------------
0000121A                           252  
0000121A= 2D 2D 2D 2D 2D 2D ...    253  INTRO       DC.B        '------------------------------------------',CR,LF
00001246= 0D 0A 20 20 20 20 ...    254              DC.B        CR,LF,'           Program Disassembler',CR,LF,CR,LF
0000126B= 2D 2D 2D 2D 2D 2D ...    255              DC.B        '------------------------------------------',CR,LF,0
00001298                           256              
00001298= 45 6E 74 65 72 20 ...    257  INPUT1      DC.B        'Enter starting address: $',0        ; Ask user for lower boundary
000012B2= 001A                     258  INPUT1_len  DC.W        INPUT1_len-INPUT1                    ; Gets the length of input string
000012B4                           259  
000012B4= 45 6E 74 65 72 20 ...    260  INPUT2      DC.B        'Enter ending address: $',0          ; Ask user for upper boundary
000012CC= 0018                     261  INPUT2_len  DC.W        INPUT2_len-INPUT2                    ; Gets the length of input string
000012CE                           262  
000012CE= 45 72 72 6F 72 21 ...    263  ERRMSG      DC.B        'Error! The input given is invalid!', 0
000012F1= 45 72 72 6F 72 21 ...    264  ERRADD      DC.B        'Error! The address given is invalid', 0
00001315                           265  
00001315= 50 72 65 73 73 20 ...    266  MORE_DATA   DC.B        'Press enter for more data',0
00001330= FFE5                     267  MORE_len    DC.W        MORE_DATA-MORE_len
00001332                           268  
00001332= 57 6F 75 6C 64 20 ...    269  CONTINUE    DC.B        'Would you like to continue disassembling? Y = 1, N = 0: ',0
0000136C= 003A                     270  CONT_len    DC.W        CONT_len-CONTINUE
0000136E                           271  
0000136E= 45 6E 64 20 6F 66 ...    272  EXIT        DC.B        'End of program',0
0000137E= 0010                     273  EXIT_len    DC.W        EXIT_len-EXIT  
00001380                           274  
00001380= 01                       275  main_buff   DC.B        1
00001381                           276  
00001381                           277  
00001381                           278  *--------------------------------------------------------------------------------------------------------------
00001381                           279  *   VARIABLES & CONSTANTS
00001381                           280  *--------------------------------------------------------------------------------------------------------------
00001381                           281  
00001381  =0000000D                282  CR          EQU         $0D
00001381  =0000000A                283  LF          EQU         $0A
00001381                           284  
00001382= 0000                     285  minBOUND    DC.W        $00000000       ; Minimum bound
00001384= FFFF                     286  maxBOUND    DC.W        $0000FFFF       ; Maximum bound
00001386                           287  
00001386= 00000001                 288  CURRENTADDR DC.L        1               ; holds the address of instruscion
0000138A                           289  
0000138A  =0000A000                290  stack       EQU         $A000           ; Stack Address
0000138A  =00000000                291  length      EQU         0               ; Effective address length to be stored in D reg
0000138A  =00000001                292  TRUE        EQU         1               ; Boolean - is true
0000138A  =00000000                293  FALSE       EQU         0               ; Boolean - is false
0000138A  =00000000                294  task0       EQU         00              ; output command
0000138A  =00000001                295  task1       EQU         01              ; output command
0000138A                           296  
0000138A                           297  
0000138A                           298  
0000138A                           299     
0000138A                           300  
0000138A                           301              END         START           ; last line of source

12 errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD1                1114
ADD2                1128
ASCII_TO_HEX        117A
BUFFER              1218
CHECK_ADDRESS       1108
CHECK_END           1178
CHECK_ERROR         1162
CHECK_START         1108
CLEAR_REG           10CE
CONTINUE            1332
CONT_LEN            136C
CONVERT_TO_HEX      118A
CR                  D
CURRENTADDR         1386
ENDBUFF             1218
EQU1                113C
EQU2                114C
EQU3                115C
ERRADD              12F1
ERRMSG              12CE
EXIT                136E
EXIT_LEN            137E
EXIT_PROGRAM        10BA
FALSE               0
GET_CAP             11E2
GET_INPUT           101E
GET_LOWERCASE       11EC
GET_NUMBER          11D8
INPUT1              1298
INPUT1_LEN          12B2
INPUT2              12B4
INPUT2_LEN          12CC
INTRO               121A
INTRODUCTION        1000
INVALID_HEX         11BC
LENGTH              0
LF                  A
MAIN_BUFF           1380
MAIN_START          100C
MAXBOUND            1384
MINBOUND            1382
MORE_DATA           1315
MORE_LEN            1330
NEXT_STEP           11F6
RETURN              120E
STACK               A000
START               1000
SUB1                1124
SUB2                1138
TASK0               0
TASK1               1
TRUE                1
